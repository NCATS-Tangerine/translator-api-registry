openapi: 3.0.3
info: 
  contact: 
    email: help@mygene.info
    name: Chunlei Wu
    x-id: https://github.com/newgene
    x-role: responsible developer
  description: Documentation of the MyGene.info Gene Query web services. Learn more about [MyGene.info](https://docs.mygene.info/en/latest/index.html)
  termsOfService: "http://mygene.info/terms/"
  title: MyGene.info API
  version: "3.0"
  x-bte:
    batch_size_limit: 1000
    request_rate_limit: 5000
  x-translator: 
    infores: "infores:mygene-info"
    component: KP
    team: 
      - "Service Provider"
    biolink-version: "4.2.2"
servers: 
  - description: Encrypted Production server
    url: https://mygene.info/v3
    x-maturity: production
tags: 
  - name: gene
  - name: annotation
  - name: query
  - name: translator
  - name: x-bte
  - name: biothings
paths:
  "/gene/{id}":
    get:
      description: >-
        By default, this will return the complete gene annotation object in JSON format. 
        See [here](https://docs.mygene.info/en/latest/doc/annotation_service.html#returned-object) 
        for an example and [here](https://docs.mygene.info/en/latest/doc/data.html#gene-object)
        for more details. If the input gene ID is not valid, 404 (NOT FOUND) will be returned.
        

        Optionally, you can pass a "fields" parameter to return only the annotation you want 
        (by filtering returned object fields). "fields" accepts any attributes (a.k.a fields) available 
        from the gene object. Multiple attributes should be separated by commas. If an attribute is not 
        available for a specific gene object, it will be ignored. Note that the attribute names are 
        case-sensitive.


        Just like the gene query service, you can also pass a "callback" parameter to make a JSONP call.
      parameters:
      ## these are provided in the docs https://docs.mygene.info/en/latest/doc/annotation_service.html
      - name: id
        description: >-
          Entrez ("1017") or Ensembl gene id ("ENSG00000123374"). A retired Entrez Gene id works too if it is 
          replaced by a new one, e.g., 245794. But a "discontinued" gene id will not return any hit, e.g., 138.
        in: path
        required: true
        example: "1017"
        schema:
          type: string
      ## species, species_facet_filter are special parameters for MyGene
      - "$ref": "#/components/parameters/species"
      - "$ref": "#/components/parameters/fields"
      - "$ref": "#/components/parameters/callback"
      - "$ref": "#/components/parameters/dotfield"
      - "$ref": "#/components/parameters/email"
      ## this is useful even when it's not noted in the docs
      - "$ref": "#/components/parameters/size"
      ## these are noted in the https://mygene.info/v3/spec endpoint; commenting out for now
      # - "$ref": "#/components/parameters/species_facet_filter"
      # - "$ref": "#/components/parameters/raw"
      # - "$ref": "#/components/parameters/rawquery"
      # - "$ref": "#/components/parameters/_sorted"
      # - "$ref": "#/components/parameters/always_list"
      # - "$ref": "#/components/parameters/allow_null"
      # - "$ref": "#/components/parameters/format"
      responses:
        '200':
          ## description from https://docs.mygene.info/en/latest/doc/response_status_codes.html
          description: A 200 status code indicates a successful query, and is accompanied by the query response payload.
      ## commenting out schemas and other status codes for now
      #     content:
      #       application/json:
      #         schema:
      #           $ref: '#/components/schemas/Chem'
      #   '404':
      #     description: A response indicating an unknown chemical ID
      tags:
      - gene
  "/gene":
    post:
      description: >-
        Although making simple GET requests above to our gene query service is sufficient in most use cases, 
        there are some times you might find it easier to batch query (e.g., retrieving gene annotations for 
        multiple genes). Fortunately, you can also make batch queries via POST requests when you need to.
      parameters:
      ## these are provided in the docs https://docs.mygene.info/en/latest/doc/chem_annotation_service.html
      - name: ids
        description: >-
          Accept multiple geneids (either Entrez or Ensembl gene ids) seperated by comma, e.g., 
          "ids=1017,1018" or "ids=695,ENSG00000123374".
          Note that currently we only take the input ids up to 1000 maximum, the rest will be omitted.


          The request body can also be used to provide these ids.
        in: query
        ## setting to false since putting this info in the request body seems to work as well
        required: false
        schema:
          type: string
      - "$ref": "#/components/parameters/fields"
      - "$ref": "#/components/parameters/species"
      - "$ref": "#/components/parameters/dotfield"
      - "$ref": "#/components/parameters/email"
      ## this is useful even when it's not noted in the docs
      - "$ref": "#/components/parameters/size"
      ## these are noted in the https://mygene.info/v3/spec endpoint; commenting out for now
      # - "$ref": "#/components/parameters/species_facet_filter"
      # - "$ref": "#/components/parameters/raw"
      # - "$ref": "#/components/parameters/rawquery"
      # - "$ref": "#/components/parameters/dotfield"
      # - "$ref": "#/components/parameters/_sorted"
      # - "$ref": "#/components/parameters/always_list"
      # - "$ref": "#/components/parameters/allow_null"
      # - "$ref": "#/components/parameters/format"
      requestBody:
        content:
          application/json:
            example:
              ids:
              - "1017"
              - "1018"
            schema:
              type: object
              properties:
                ids:
                  description: >-
                    Accepts multiple gene ids. Note that currently we only take the input ids 
                    up to 1000 maximum, the rest will be omitted.
                  type: array
                  items:
                    type: string
      responses:
        '200':
          description: A 200 status code indicates a successful query, and is accompanied by the query response payload.
      tags:
      - gene
  "/metadata":
    get:
      description: Get metadata about the data available from the API
      ## these are noted in the https://mygene.info/v3/spec endpoint; commenting out for now
      # parameters:
      # - "$ref": "#/components/parameters/format"
      # - "$ref": "#/components/parameters/raw"
      responses:
        '200':
          description: A 200 status code indicates a successful query, and is accompanied by the query response payload.
      tags:
      - metadata
  "/metadata/fields":
    get:
      description: Get metadata about the data fields available from the API
      ## these are noted in the https://mygene.info/v3/spec endpoint; commenting out for now
      # parameters:
      # - "$ref": "#/components/parameters/format"
      # - "$ref": "#/components/parameters/raw"
      # - "$ref": "#/components/parameters/search"
      # - "$ref": "#/components/parameters/prefix"
      responses:
        '200':
          description: A 200 status code indicates a successful query, and is accompanied by the query response payload.
      tags:
      - metadata
  "/query":
    get:
      description: >-
        MyGene.info chemical query web service. In the output, "total" in the output gives the total number 
        of matching hits, while the actual hits are returned under "hits" field.
      parameters:
      - name: q
        ## description partially from https://docs.mygene.info/en/latest/doc/query_service.html#query-syntax
        description: >-
          Required, passing user query. The detailed query syntax for parameter is explained 
          [here](https://docs.mygene.info/en/latest/doc/query_service.html#query-syntax).
        in: query
        required: true
        example: CDK2
        schema:
          type: string
      ## species, species_facet_filter, entrezonly, ensemblonly,
      ##   exists, missing, post_filter, include_tax_tree
      ##   are special parameters for MyGene
      - "$ref": "#/components/parameters/fields"
      - "$ref": "#/components/parameters/species"
      - "$ref": "#/components/parameters/size"
      - "$ref": "#/components/parameters/from"
      - "$ref": "#/components/parameters/fetch_all"
      - "$ref": "#/components/parameters/scroll_id"
      - "$ref": "#/components/parameters/sort"
      - "$ref": "#/components/parameters/facets"
      - "$ref": "#/components/parameters/facet_size"
      - "$ref": "#/components/parameters/species_facet_filter"
      - "$ref": "#/components/parameters/entrezonly"
      - "$ref": "#/components/parameters/ensemblonly"
      - "$ref": "#/components/parameters/callback"
      - "$ref": "#/components/parameters/dotfield"
      - "$ref": "#/components/parameters/email"
      ## these are noted in the https://mygene.info/v3/spec endpoint; commenting out for now
      # - "$ref": "#/components/parameters/exists"
      # - "$ref": "#/components/parameters/missing"
      # - "$ref": "#/components/parameters/post_filter"
      # - "$ref": "#/components/parameters/include_tax_tree"
      # - "$ref": "#/components/parameters/aggs"
      # - "$ref": "#/components/parameters/userquery"
      # - "$ref": "#/components/parameters/explain"
      # - "$ref": "#/components/parameters/raw"
      # - "$ref": "#/components/parameters/rawquery"
      # - "$ref": "#/components/parameters/_sorted"
      # - "$ref": "#/components/parameters/always_list"
      # - "$ref": "#/components/parameters/allow_null"
      # - "$ref": "#/components/parameters/format
      responses:
        '200':
          description: A 200 status code indicates a successful query, and is accompanied by the query response payload.
      ## commenting out schemas and other status codes for now
      #     content:
      #       application/json:
      #         schema:
      #           "$ref": "#/components/schemas/QueryResult"
      #   '400':
      #     content:
      #       application/json:
      #         schema:
      #           "$ref": "#/components/schemas/ErrorResult"
      #     description: A response indicating an improperly formatted query
      # description: Make queries and return matching gene hits. Supports JSONP and CORS
      #   as well.
      tags:
      - query
    post: 
      description: >-
        Although making simple GET requests above to our chemical query service is sufficient for most use cases, 
        there are times you might find it more efficient to make batch queries (e.g., retrieving gene annotation 
        for multiple genes). Fortunately, you can also make batch queries via POST requests when you need to.


        The "query" field in the returned object indicates the matching query term. If a query term has no match, 
        it will return with a "notfound" field with the value "true".
      parameters:
      ## these are provided in the docs https://docs.mygene.info/en/latest/doc/query_service.html#batch-queries-via-post
      - name: q
        description: >-
          Accepts multiple values separated by commas. Note that currently we only take the input values up to 1000 
          maximum, the rest will be omitted.


          The request body can also be used to provide these ids.
        in: query
        ## setting to false since putting this info in the request body seems to work as well
        required: false
        schema:
          type: array
          items:
            type: string
      - name: scopes
        description: >-
          Optional, specify one or more fields (separated by commas) to search. 
          The available "fields" can be passed to "scopes" parameter are listed 
          [here](https://docs.mygene.info/en/latest/doc/data.html#available-fields). Default: _id


          The request body can also be used to provide this information.
        in: query
        ## setting to false since putting this info in the request body seems to work as well
        required: false
        schema:
          type: string
      ## species, species_facet_filter, entrezonly, ensemblonly,
      ##   exists, missing, post_filter, include_tax_tree
      ##   are special parameters for MyGene
      - "$ref": "#/components/parameters/species"
      - "$ref": "#/components/parameters/fields"
      - "$ref": "#/components/parameters/dotfield"
      - "$ref": "#/components/parameters/email"
      ## these aren't noted in the docs for POST, but they are in GET or are useful
      - "$ref": "#/components/parameters/size"
      - "$ref": "#/components/parameters/from"
      - "$ref": "#/components/parameters/fetch_all"
      - "$ref": "#/components/parameters/scroll_id"
      - "$ref": "#/components/parameters/sort"
      - "$ref": "#/components/parameters/facets"
      - "$ref": "#/components/parameters/facet_size"
      - "$ref": "#/components/parameters/species_facet_filter"
      - "$ref": "#/components/parameters/entrezonly"
      - "$ref": "#/components/parameters/ensemblonly"
      - "$ref": "#/components/parameters/callback"
      ## these are noted in the https://mygene.info/v3/spec endpoint; commenting out for now
      ##   others haven't been written down here: with_total, analyzer
      # - "$ref": "#/components/parameters/exists"
      # - "$ref": "#/components/parameters/missing"
      # - "$ref": "#/components/parameters/post_filter"
      # - "$ref": "#/components/parameters/include_tax_tree"
      # - "$ref": "#/components/parameters/aggs"
      # - "$ref": "#/components/parameters/userquery"
      # - "$ref": "#/components/parameters/explain"
      # - "$ref": "#/components/parameters/raw"
      # - "$ref": "#/components/parameters/rawquery"
      # - "$ref": "#/components/parameters/_sorted"
      # - "$ref": "#/components/parameters/always_list"
      # - "$ref": "#/components/parameters/allow_null"
      # - "$ref": "#/components/parameters/format
      requestBody:
        content:
          application/json:
            example:
              q:
              - "1017"
              - "1018"
              scopes:
              - "entrezgene"
            schema:
              type: object
              properties:
                q:
                  description: >-
                    Accepts multiple values separated by commas. Note that currently we only take the input values 
                    up to 1000 maximum, the rest will be omitted.
                  type: array
                  items:
                    type: string
                scopes:
                  description: >-
                    Specify one or more fields (separated by commas) to search. 
                    The available "fields" can be passed to "scopes" parameter are listed 
                    [here](https://docs.mygene.info/en/latest/doc/data.html#available-fields). Default: _id
                  type: array
                  items:
                    type: string
      responses:
        '200':
          description: A 200 status code indicates a successful query, and is accompanied by the query response payload.
      ## commenting out schemas and other status codes for now
      #     content:
      #       application/json:
      #         schema:
      #           "$ref": "#/components/schemas/QueryPOSTResult"
      #   '400':
      #     content:
      #       application/json:
      #         schema:
      #           "$ref": "#/components/schemas/ErrorResult"
      #     description: A response indicating an improperly formatted query
      # description: Make batch gene queries and return matching gene hits
      tags:
      - query
components: 
  parameters: 
    ## these are specific to MyGene
    ensemblonly: 
      name: ensemblonly
      description: >-
        Optional. When passed as “true” or “1”, the query returns only the hits with valid Ensembl gene ids. Default: false.
      in: query
      schema: 
        type: boolean
        default: false
    entrezonly: 
      name: entrezonly
      description: >-
        Optional. When passed as “true” or “1”, the query returns only the hits with valid Entrez gene ids. Default: false.
      in: query
      schema: 
        type: boolean
        default: false
    species: 
      name: species
      description: >-
        Optional, can be used to limit the gene hits from given species. 
        You can use "common names" for nine common species (human, mouse, 
        rat, fruitfly, nematode, zebrafish, thale-cress, frog and pig). 
        All other species, you can provide their taxonomy ids from 
        [NCBI Taxonomy](https://www.ncbi.nlm.nih.gov/taxonomy). See more details 
        [here](https://docs.mygene.info/en/latest/doc/data.html#species). 
        Multiple species can be passed using comma as a separator. Passing "all" will 
        query against all available species. Default: all.
      in: query
      required: false
      schema:
        type: array
        items:
          type: string
          default: all
    species_facet_filter: 
      name: species_facet_filter
      description: >-
        Optional, relevant when faceting on species (i.e., "facets=taxid" are passed). 
        It's used to pass species filter without changing the scope of faceting, 
        so that the returned facet counts won't change. Either species name or taxonomy id 
        can be used, just like "species" parameter above. See examples of faceted queries 
        [here](https://docs.mygene.info/en/latest/doc/query_service.html#faceted-queries).
      in: query
      required: false
      schema:
        type: array
        items:
          type: string
    ## these are specific to MyGene, but only noted in the https://mychem.info/v1/spec endpoint; commenting out for now
    # exists: 
    #   name: exists
    #   in: query
    #   required: false
    #   schema:
    #     type: array
    #     items:
    #       type: string
    # include_tax_tree: 
    #   name: include_tax_tree
    #   in: query
    #   required: false
    #   schema:
    #     type: boolean
    # missing: 
    #   name: missing
    #   in: query
    #   required: false
    #   schema:
    #     type: array
    #     items:
    #       type: string
    # post_filter: 
    #   name: post_filter
    #   in: query
    #   required: false
    #   schema:
    #     type: string
    callback:
      name: callback
      description: >-
        Optional, you can pass a "callback" parameter to make a JSONP call.
      in: query
      required: false
      schema:
        type: string
    dotfield:
      name: dotfield
      description: >-
        Optional, can be used to control the format of the returned object. 
        If "dotfield" is true, the returned data object is returned flattened (no nested objects) 
        using dotfield notation for key names. Default: false.
      in: query
      required: false
      schema:
        type: boolean
        default: false
    email:
      name: email
      description: >-
        Optional, if you are regular users of our services, we encourage you to provide us an email, 
        so that we can better track the usage or follow up with you.
      in: query
      required: false
      schema:
        type: string
    facet_size:
      name: facet_size
      description: >-
        Optional, an integer (1 <= facet_size <= 1000) that specifies how many buckets to return in a 
        [faceted query](https://docs.mychem.info/en/latest/doc/chem_query_service.html?highlight=from#faceted-queries).
      in: query
      required: false
      schema:
        type: integer
        default: 10
    facets:
      name: facets
      description: >-
        Optional, a single field or comma-separated fields to return facets, can only be used on non-free text fields. 
        E.g. "facets=chembl.molecule_properties.full_mwt". See [examples of faceted queries 
        here](https://docs.mychem.info/en/latest/doc/chem_query_service.html?highlight=from#faceted-queries).
      in: query
      required: false
      schema:
        type: array
        items:
          type: string
    fetch_all:
      name: fetch_all
      description: >-
        Optional, a boolean, which when TRUE, allows fast retrieval of all unsorted query hits. 
        The return object contains a _scroll_id field, which when passed as a parameter to the query endpoint 
        (see the scroll_id parameter), returns the next 1000 query results. Setting fetch_all = TRUE causes 
        the results to be inherently unsorted, therefore the sort parameter is ignored. For more information, 
        see [examples using fetch_all 
        here](https://docs.mychem.info/en/latest/doc/chem_query_service.html?highlight=from#scrolling-queries). 
        Default: FALSE.
      in: query
      required: false
      schema:
        type: boolean
        default: false
    fields:
      name: fields
      description: >-
        Optional, can be a comma-separated list to limit the fields returned from the object. 
        If "fields=all", all available fields will be returned. Look 
        [here](https://docs.mychem.info/en/latest/doc/data.html#available-fields) for a list of available fields. 
        

        Note that it supports dot notation as well, e.g., you can pass "chebi.name". 
        Default: "fields=all". 
        The parameter "filter" is an alias for this parameter.
      in: query
      required: false
      schema:
        type: string
        default: all
    from:
      name: from
      description: >-
        Optional, the number of matching hits to skip, starting from 0. Default: 0. 
      in: query
      required: false
      schema:
        type: integer
        default: 0
    scroll_id:
      name: scroll_id
      description: >-
        Optional, a string containing the _scroll_id returned from a query request with fetch_all = TRUE. 
        Supplying a valid scroll_id will return the next 1000 unordered results. If the next results are 
        not obtained within 1 minute of the previous set of results, the scroll_id becomes stale, and a 
        new one must be obtained with another query request with fetch_all = TRUE. All other parameters are 
        ignored when the scroll_id parameter is supplied. For more information see [examples using scroll_id 
        here](https://docs.mychem.info/en/latest/doc/chem_query_service.html?highlight=from#scrolling-queries).
      in: query
      required: false
      schema:
        type: string
    size:
      name: size
      description: >-
        Optional, the maximum number of matching hits to return (with a cap of 1000 at the moment). Default: 10.
        The combination of "size" and "from" parameters can be used to get paging for a large query.
      in: query
      required: false
      schema:
        type: integer
        default: 10
    sort:
      name: sort
      description: >-
        Optional, the comma-separated fields to sort on. Prefix with "-" for descending order, otherwise in ascending order. 
        Default: sort by matching scores in descending order.
      in: query
      required: false
      schema:
        type: array
        items:
          type: string
    ## these are noted in the https://mychem.info/v1/spec endpoint; commenting out for now
    # _sorted:
    #   name: _sorted
    #   in: query
    #   required: false
    #   schema:
    #     type: boolean
    #     default: true
    # aggs:
    #   name: aggs
    #   in: query
    #   required: false
    #   schema:
    #     type: array
    #     items:
    #       type: string
    # allow_null:
    #   name: allow_null
    #   in: query
    #   required: false
    #   schema:
    #     type: array
    #     items:
    #       type: string
    # always_list:
    #   name: always_list
    #   in: query
    #   required: false
    #   schema:
    #     type: array
    #     items:
    #       type: string
    # explain:
    #   name: explain
    #   in: query
    #   required: false
    #   schema:
    #     type: boolean
    # format:
    #   name: format
    #   description: 'controls output format of server response, currently supports:
    #     "json", "jsonld", "html". Type: string. Default: json.'
    #   in: query
    #   required: false
    #   schema:
    #     type: string
    #     default: json
    # prefix:
    #   name: prefix
    #   in: query
    #   required: false
    #   schema:
    #     type: string
    # raw:
    #   name: raw
    #   in: query
    #   required: false
    #   schema:
    #     type: boolean
    # rawquery:
    #   name: rawquery
    #   in: query
    #   required: false
    #   schema:
    #     type: boolean
    # search:
    #   name: search
    #   in: query
    #   required: false
    #   schema:
    #     type: string
    # userquery:
    #   name: userquery
    #   in: query
    #   required: false
    #   schema:
    #     type: string
  # schemas:
  #   Chem:
  #     properties:
  #       _id:
  #         type: string
  #     required:
  #     - _id
  #     type: object
  #   ErrorResult:
  #     properties:
  #       message:
  #         type: string
  #       success:
  #         type: boolean
  #     type: object
  #   QueryPOSTResult:
  #     items:
  #       allOf:
  #       - "$ref": "#/components/schemas/Chem"
  #       - properties:
  #           _score:
  #             format: float
  #             type: number
  #           query:
  #             type: string
  #         type: object
  #     type: array
  #   QueryResult:
  #     properties:
  #       hits:
  #         items:
  #           "$ref": "#/components/schemas/Chem"
  #         type: array
  #       max_score:
  #         format: float
  #         type: number
  #       took:
  #         type: integer
  #       total:
  #         type: integer
  #     type: object
  #   int64_or_array:
  #     oneOf:
  #     - items:
  #         format: int64
  #         type: integer
  #       type: array
  #     - format: int64
  #       type: integer
  #   string_or_array:
  #     oneOf:
  #     - items:
  #         type: string
  #       type: array
  #     - type: string
  x-bte-annotations: 
  ## Not including Gene <-> Transcript <-> Protein or Gene <-> Protein due to conflation, lack of use in Translator right now
  ## Pathway <-> Gene data notes:
  ## - for ConsensusPathDB, look at "content information" tab at http://cpdb.molgen.mpg.de/CPDB to see versions of the pathway databases they used
  ## - pathway info includes Reactome, KEGG.PATHWAY, Wikipathways, Biocarta
  ##   However, SRI ID resolver only accepts SMPDB, REACT, GO, PANTHER.PATHWAY right now
  ##   not included: humancyc, mousecyc, netpath, pharmgkb, pid, yeastcyc
  ## - Gene ID: all genes with pathway info have entrezgene field (NCBIGene namespace) https://mygene.info/v3/query?q=_exists_:pathway%20AND%20NOT%20_exists_:entrezgene
  ## - knowledge_level / agent_type
  ##   - reactome: manually curated by experts https://reactome.org/what-is-reactome
  ##   - kegg pathway: manually drawn https://www.genome.jp/kegg/pathway.html
  ##   - wikipathways: manually curated by community https://www.wikipathways.org/about.html
  ##   - biocarta: curated, assuming manually https://maayanlab.cloud/Harmonizome/dataset/Biocarta%20Pathways
    PathwayHasGene:
    ## - this is a reverse operation
    ## - Currently only including Reactome, KEGG.PATHWAY, Wikipathways, Biocarta
    ##   these all have diff ID formats, so their IDs can be put together in the same request
    ##   (ex: won't accidentally retrieve matches from the wrong namespace)
    ## - just in case, use pagination (very general, root-level pathways can have >1000 genes listed)
      response_field_root: hits
      inputs: 
        category: Pathway
        ## data has no "merging" for synonymous pathway IDs from diff namespaces
        ## but we probably won't encounter any input IDs w/ >1 pathway ID. Because right now, 
        ##   SRI node-norm doesn't find synonymous pathway IDs either (no entity-resolving) 
        use_all_namespaces: true
        namespaces:
          - prefix: REACT
            name_field: pathway.reactome.name
            match_field: query
          - prefix: KEGG.PATHWAY
            name_field: pathway.kegg.name
            match_field: query
          - prefix: WIKIPATHWAYS
            name_field: pathway.wikipathways.name
            match_field: query
          - prefix: BIOCARTA
            name_field: pathway.biocarta.name
            match_field: query
      predicate: has_participant
      outputs: 
        category: Gene
        namespaces:
          - prefix: NCBIGene
            id_field: entrezgene   ## single ID, no prefix
      request_info:
        path: "/query"   ## use same format that paths section does
        method: post     ## use same format that paths section does (lower case)
        support_batch: true
        use_pagination: true    ## PLACEHOLDER: will add more required pagination info later
        request_body:
          ## single ID, no prefix
          q: "{{ input_ids }}"
          scopes: pathway.reactome.id,pathway.kegg.id,pathway.wikipathways.id,pathway.biocarta.id
        parameters:
          fields: >-
            entrezgene,
            pathway.reactome.name,
            pathway.kegg.name,
            pathway.wikipathways.name,
            pathway.biocarta.name
          size: 1000
          with_total: true  ## for pagination
      provenance:
        - namespace_pair: [ REACT, NCBIGene ]
          knowledge_level: knowledge_assertion
          agent_type: manual_agent
          sources:
          ## MyGene gets this info directly from Reactome
            - id: "infores:reactome"
              role: primary_knowledge_source
        - namespace_pair: [ KEGG.PATHWAY, NCBIGene ]
          knowledge_level: knowledge_assertion
          agent_type: manual_agent
          sources:
            - id: "infores:kegg"
              role: primary_knowledge_source
            - id: "infores:cpdb"
              role: aggregator_knowledge_source
              upstream: ["infores:kegg"]
        - namespace_pair: [ WIKIPATHWAYS, NCBIGene ]
          knowledge_level: knowledge_assertion
          agent_type: manual_agent
          sources:
            - id: "infores:wikipathways"
              role: primary_knowledge_source
            - id: "infores:cpdb"
              role: aggregator_knowledge_source
              upstream: ["infores:wikipathways"]
        - namespace_pair: [ BIOCARTA, NCBIGene ]
          knowledge_level: knowledge_assertion
          agent_type: manual_agent
          sources:
          ## infores ID doesn't exist yet! Need to add to infores catalog
            - id: "infores:biocarta"
              role: primary_knowledge_source
            - id: "infores:cpdb"
              role: aggregator_knowledge_source
              upstream: ["infores:biocarta"]
      ## NO RESPONSE MAPPING: no edge-attributes
      test_examples:
        - input_curie: "REACT:R-HSA-70895"         ## Branched-chain amino acid catabolism
          output_curie: "NCBIGene:10295"           ## BCKDK
        - input_curie: "KEGG.PATHWAY:hsa00120"     ## Primary bile acid biosynthesis - Homo sapiens (human)
          output_curie: "NCBIGene:8309"            ## ACOX2
        - input_curie: "WIKIPATHWAYS:WP2034"       ## Leptin signaling pathway
          output_curie: "NCBIGene:3953"            ## LEPR
        - input_curie: "BIOCARTA:raspathway"
          output_curie: "NCBIGene:3265"            ## HRAS
    GeneInPathway:
    ## NO PAGINATION: 1 gene won't match >~1000 gene documents
      inputs:
        category: Gene
        namespaces:
          - prefix: NCBIGene
            match_field: query
      predicate: participates_in
      outputs:
        category: Pathway
        ## each nested pathway-object has only 1 ID from 1 namespace. So default behavior to pick "only one namespace" is fine. 
        ## id_field values are single ID only, no prefixes
        namespaces:
        ## old comments say BTE had buggy behavior with handing names...but I'm not sure since operations included them
          - prefix: "REACT"
            id_field: pathway.reactome.id
            name_field: pathway.reactome.name
          - prefix: "KEGG.PATHWAY"
            id_field: pathway.kegg.id
            name_field: pathway.kegg.name
          - prefix: WIKIPATHWAYS
            id_field: pathway.wikipathways.id
            name_field: pathway.wikipathways.name
          - prefix: BIOCARTA
            id_field: pathway.biocarta.id
            name_field: pathway.biocarta.name
      request_info:
        path: "/query"
        method: post
        support_batch: true
        request_body:
          q: "{{ input_ids }}"
          scopes: entrezgene
        parameters:
          fields: >-
            pathway.reactome.id,pathway.reactome.name,
            pathway.kegg.id,pathway.kegg.name,
            pathway.wikipathways.id,pathway.wikipathways.name,
            pathway.biocarta.id,pathway.biocarta.name
          size: 100      ## should be overestimate, shouldn't get 1 gene ID -> 100 gene documents
      provenance:
        - namespace_pair: [ NCBIGene, REACT ]
          knowledge_level: knowledge_assertion
          agent_type: manual_agent
          sources:
            - id: "infores:reactome"
              role: primary_knowledge_source
        - namespace_pair: [ NCBIGene, KEGG.PATHWAY ]
          knowledge_level: knowledge_assertion
          agent_type: manual_agent
          sources:
            - id: "infores:kegg"
              role: primary_knowledge_source
            - id: "infores:cpdb"
              role: aggregator_knowledge_source
              upstream: ["infores:kegg"]
        - namespace_pair: [ NCBIGene, WIKIPATHWAYS ]
          knowledge_level: knowledge_assertion
          agent_type: manual_agent
          sources:
            - id: "infores:wikipathways"
              role: primary_knowledge_source
            - id: "infores:cpdb"
              role: aggregator_knowledge_source
              upstream: ["infores:wikipathways"]
        - namespace_pair: [ NCBIGene, BIOCARTA ]
          knowledge_level: knowledge_assertion
          agent_type: manual_agent
          sources:
            - id: "infores:biocarta"
              role: primary_knowledge_source
            - id: "infores:cpdb"
              role: aggregator_knowledge_source
              upstream: ["infores:biocarta"]
      ## NO RESPONSE MAPPING: no edge-attributes
      test_examples:
        - input_curie: "NCBIGene:1629"            ## DBT
          output_curie: "REACT:R-HSA-70895"       ## Branched-chain amino acid catabolism
        - input_curie: "NCBIGene:1629"            ## DBT
          output_curie: "KEGG.PATHWAY:hsa00280"   ## Valine, leucine and isoleucine degradation - Homo sapiens (human)
        - input_curie: "NCBIGene:8309"              ## ACOX2
          output_curie: "WIKIPATHWAYS:WP3942"       ## PPAR signaling pathway
        - input_curie: "NCBIGene:5608"              ## MAP2K6
          output_curie: "BIOCARTA:p38mapkpathway"   ## p38 mapk signaling pathway
  # ## knowledge_level / agent_type for ncbi-gene: need separation by evidence code for more-specific settings
  # ## has info on how it gets go-annotation data https://www.ncbi.nlm.nih.gov/books/NBK3840/#genefaq.GO_terms
  #   involvedInBP:
  #     - supportBatch: true
  #       useTemplating: true
  #       inputs: 
  #         - id: NCBIGene
  #           semantic: Gene
  #       requestBody: 
  #         body: 
  #           q: "{{ queryInputs }}"  ## no prefix
  #           scopes: entrezgene
  #       outputs: 
  #         - id: GO
  #           semantic: BiologicalProcess
  #       parameters: 
  #         ## all records with go.BP field also have entrezgene field
  #         ## not including: name, category/gocategory (not needed)
  #       ## commenting out because data-processing / biolink-modeling issues
  #         # fields: >-
  #         #   go.BP.id,
  #         #   go.BP.evidence,
  #         #   go.BP.pubmed,
  #         #   go.BP.qualifier
  #         fields: go.BP.id,go.BP.pubmed
  #         species: human
  #         size: 1000
  #       predicate: participates_in
  #       source: "infores:ncbi-gene"   ## which got from GO Annotations...
  #       knowledge_level: knowledge_assertion
  #       agent_type: not_provided
  #       response_mapping: 
  #         $ref: "#/components/x-bte-response-mapping/biologicalProcess"
  #       testExamples:
  #         - qInput: "NCBIGene:632"    ## BGLAP
  #           oneOutput: "GO:0001501"   ## skeletal system development
  #   BPToGene: 
  #     - supportBatch: true
  #       useTemplating: true
  #       inputs: 
  #         - id: GO
  #           semantic: BiologicalProcess
  #       requestBody: 
  #         body: 
  #           q: "{{ queryInputs | replPrefix('GO') }}"      ## HAS PREFIX (GO)
  #           scopes: go.BP.id
  #       outputs: 
  #         - id: NCBIGene
  #           semantic: Gene
  #       parameters: 
  #         ## all records with go.BP field also have entrezgene field
  #         fields: entrezgene
  #         species: human
  #         size: 1000  ## note size limit
  #       predicate: has_participant
  #       source: "infores:ncbi-gene"   ## which got from GO Annotations...
  #       knowledge_level: knowledge_assertion
  #       agent_type: not_provided
  #       response_mapping: 
  #         $ref: "#/components/x-bte-response-mapping/entrezgene"
  #       testExamples:
  #         - qInput: "GO:0001501"         ## skeletal system development
  #           oneOutput: "NCBIGene:5741"   ## PTH
  #   enablesMF:
  #     - supportBatch: true
  #       useTemplating: true
  #       inputs: 
  #         - id: NCBIGene
  #           semantic: Gene
  #       requestBody: 
  #         body: 
  #           q: "{{ queryInputs }}"  ## no prefix
  #           ## all records with go.MF field also have entrezgene field
  #           scopes: entrezgene
  #       outputs: 
  #         - id: GO
  #           semantic: MolecularActivity
  #       parameters: 
  #         ## not including: name, category/gocategory (not needed)
  #       ## commenting out because data-processing / biolink-modeling issues\
  #         # fields: >-
  #         #   go.MF.id,
  #         #   go.MF.evidence,
  #         #   go.MF.pubmed,
  #         #   go.MF.qualifier
  #         fields: go.MF.id,go.MF.pubmed
  #         species: human
  #         size: 1000
  #       predicate: enables
  #       source: "infores:ncbi-gene"   ## which got from GO Annotations...
  #       knowledge_level: knowledge_assertion
  #       agent_type: not_provided
  #       response_mapping: 
  #         $ref: "#/components/x-bte-response-mapping/molecularFunction"
  #       testExamples:
  #         - qInput: "NCBIGene:1629"   ## DBT
  #           oneOutput: "GO:0031405"   ## lipoic acid binding
  #   MFToGene:
  #     - supportBatch: true
  #       useTemplating: true
  #       inputs: 
  #         - id: GO
  #           semantic: MolecularActivity
  #       requestBody: 
  #         body: 
  #           q: "{{ queryInputs | replPrefix('GO') }}"      ## HAS PREFIX (GO)
  #           scopes: go.MF.id
  #       outputs: 
  #         - id: NCBIGene
  #           semantic: Gene
  #       parameters: 
  #         ## all records with go.MF field also have entrezgene field
  #         fields: entrezgene
  #         species: human
  #         size: 1000  ## note size limit
  #       predicate: enabled_by
  #       source: "infores:ncbi-gene"   ## which got from GO Annotations...
  #       knowledge_level: knowledge_assertion
  #       agent_type: not_provided
  #       response_mapping: 
  #         $ref: "#/components/x-bte-response-mapping/entrezgene"
  #       testExamples:
  #         - qInput: "GO:0008147"   ## structural constituent of bone
  #           oneOutput: "NCBIGene:632"   ## BGLAP
  #   involvedInCC: 
  #     - supportBatch: true
  #       useTemplating: true
  #       inputs: 
  #         - id: NCBIGene
  #           semantic: Gene
  #       requestBody: 
  #         body: 
  #           q: "{{ queryInputs }}"  ## no prefix
  #           scopes: entrezgene
  #       outputs: 
  #         - id: GO
  #           semantic: CellularComponent
  #       parameters: 
  #         ## all records with go.CC field also have entrezgene field
  #         ## not including: name, category/gocategory (not needed)
  #       ## commenting out because data-processing / biolink-modeling issues
  #         # fields:  >-
  #         #   go.CC.id,
  #         #   go.CC.evidence,
  #         #   go.CC.pubmed,
  #         #   go.CC.qualifier
  #         fields: go.CC.id,go.CC.pubmed
  #         species: human
  #         size: 1000
  #       predicate: active_in
  #       source: "infores:ncbi-gene"   ## which got from GO Annotations...
  #       knowledge_level: knowledge_assertion
  #       agent_type: not_provided
  #       response_mapping: 
  #         $ref: "#/components/x-bte-response-mapping/cellularComponent"
  #       testExamples:
  #         - qInput: "NCBIGene:5741"   ## PTH
  #           oneOutput: "GO:0005576"   ## extracellular region
  #   CCToGene: 
  #     - supportBatch: true
  #       useTemplating: true
  #       inputs: 
  #         - id: GO
  #           semantic: CellularComponent
  #       requestBody: 
  #         body: 
  #           q: "{{ queryInputs | replPrefix('GO') }}"      ## HAS PREFIX (GO)
  #           scopes: go.CC.id
  #       outputs: 
  #         - id: NCBIGene
  #           semantic: Gene
  #       parameters: 
  #         ## all records with go.CC field also have entrezgene field
  #         fields: entrezgene
  #         species: human
  #         size: 1000  ## note size limit
  #       predicate: has_active_component
  #       source: "infores:ncbi-gene"   ## which got from GO Annotations...
  #       knowledge_level: knowledge_assertion
  #       agent_type: not_provided
  #       response_mapping: 
  #         $ref: "#/components/x-bte-response-mapping/entrezgene"
  #       testExamples:
  #         - qInput: "GO:0033268"         ## node of Ranvier
  #           oneOutput: "NCBIGene:6326"   ## SCN2A
  # ## knowledge_level / agent_type: clingen
  # ##   seems to be heavily manually curated  https://www.clinicalgenome.org/start/
  #   geneToDisease:
  #     - supportBatch: true
  #       useTemplating: true
  #       inputs: 
  #         - id: NCBIGene
  #           semantic: Gene
  #       requestBody: 
  #         body: 
  #           q: "{{ queryInputs }}"  ## no prefix
  #           scopes: entrezgene
  #       outputs: 
  #         - id: MONDO
  #           semantic: Disease
  #       parameters: 
  #         ## all records with clingen field have entrezgene, mondo fields
  #         ## not including: sop, disease_label
  #       ## commenting out because data-processing / biolink-modeling issues
  #         # fields: >-
  #         #   clingen.clinical_validity.mondo,
  #         #   clingen.clinical_validity.classification,
  #         #   clingen.clinical_validity.online_report
  #         fields: clingen.clinical_validity.mondo,clingen.clinical_validity.online_report
  #         species: human
  #         size: 1000
  #       ## using related_to because....
  #       ## - the strength of the assertion being made (is this gene related to disease)
  #       ##   is specified by the clingen.clinical_validity.classification field (see response-mapping)
  #       ## - reference: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5473734/
  #       ## - possible values: definitive, moderate, limited, disputed, refuted (!!!), no known disease relationship (!!!)
  #       ##     can be a list if there were multiple assertions/clinical_validity objects
  #       predicate: related_to
  #       source: "infores:clingen"
  #       knowledge_level: knowledge_assertion
  #       agent_type: manual_agent
  #       response_mapping: 
  #         $ref: "#/components/x-bte-response-mapping/clingen"
  #       testExamples:
  #         - qInput: "NCBIGene:23126"     ## POGZ
  #           oneOutput: "MONDO:0014606"   ## intellectual disability-microcephaly-strabismus-behavioral abnormalities syndrome
  #   diseaseToGene:
  #     - supportBatch: true
  #       useTemplating: true
  #       inputs: 
  #         - id: MONDO
  #           semantic: Disease
  #       requestBody: 
  #         body: 
  #           q: "{{ queryInputs | replPrefix('MONDO') }}"  ## HAS PREFIX (MONDO)
  #           scopes: clingen.clinical_validity.mondo
  #       outputs: 
  #         - id: NCBIGene
  #           semantic: Gene
  #       parameters: 
  #         ## all records with clingen field have entrezgene, mondo fields
  #         fields: entrezgene
  #         species: human
  #         size: 1000
  #       predicate: related_to
  #       source: "infores:clingen"
  #       knowledge_level: knowledge_assertion
  #       agent_type: manual_agent
  #       response_mapping: 
  #         $ref: "#/components/x-bte-response-mapping/entrezgene"
  #       testExamples:
  #         - qInput: "MONDO:0014606"       ## intellectual disability-microcephaly-strabismus-behavioral abnormalities syndrome
  #           oneOutput: "NCBIGene:23126"   ## POGZ
  #   ## pantherdb gives orthologs and paralogs, which are both homologs. Hence we use homolog
  #   ## update 2024: can use less namespaces I think. Can ask what fields are always there
  #   ## - entrezgene or pantherdb.uniprot_kb as input for forward direction
  #   ## - pantherdb.ortholog.uniprot_kb as output for forward direction
  #   ## currently written: MGI 
  #   ## Also have Ensembl (for specific non-human species) and UniprotKB (for all orthologs)
  #   ## - knowledge_level / agent_type: 
  #   ##   Paper Figure 4 seems to show that automated pipeline creates orthologs, not really any manual-curation.
  #   ##   https://onlinelibrary.wiley.com/doi/10.1002/pro.4218
  #   hasHomolog-MGI: 
  #     - supportBatch: true
  #       useTemplating: true
  #       inputs: 
  #         - id: HGNC
  #           semantic: Gene
  #       requestBody: 
  #         body: 
  #           q: "{{ queryInputs }}"  ## no prefix
  #           scopes: pantherdb.HGNC
  #       outputs: 
  #         - id: MGI
  #           semantic: Gene
  #       parameters: 
  #         ## almost all records with pantherdb.ortholog fields also have the entrezgene field
  #         ##   > 145,000 records have both fields, vs ~ 3600 records don't have the entrezgene field
  #       ## commenting out because data-processing / biolink-modeling issues
  #         # fields: >-
  #         #   pantherdb.ortholog.MGI,
  #         #   pantherdb.ortholog.taxid
  #         fields: pantherdb.ortholog.MGI
  #         size: 1000
  #       predicate: homologous_to
  #       source: "infores:panther"
  #       knowledge_level: knowledge_assertion
  #       agent_type: computational_model
  #       response_mapping: 
  #         $ref: "#/components/x-bte-response-mapping/pantherMGI"
  #       testExamples:
  #         - qInput: "HGNC:20589"       ## KCMF1
  #           oneOutput: "MGI:1921537"   ## Kcmf1
  #   hasHomolog-MGI-rev: 
  #     - supportBatch: true
  #       useTemplating: true
  #       inputs: 
  #         - id: MGI
  #           semantic: Gene
  #       requestBody: 
  #         body: 
  #           q: "{{ queryInputs | rmPrefix | join(',') }}"  ## no prefix
  #           scopes: pantherdb.ortholog.MGI
  #       outputs:
  #         - id: HGNC
  #           semantic: Gene
  #       parameters: 
  #         ## almost all records with pantherdb.ortholog fields also have the entrezgene field
  #         ##   > 145,000 records have both fields, vs ~ 3600 records don't have the entrezgene field
  #         fields: pantherdb.HGNC
  #         size: 1000
  #       predicate: homologous_to
  #       source: "infores:panther"
  #       knowledge_level: knowledge_assertion
  #       agent_type: computational_model
  #       response_mapping: 
  #         $ref: "#/components/x-bte-response-mapping/pantherHGNC"
  #       testExamples:
  #         - qInput: "MGI:1916384"     ## Fam25c
  #           oneOutput: "HGNC:23586"   ## FAM25C
  # x-bte-response-mapping:
  #   entrezgene: 
  #     NCBIGene: entrezgene   ## no prefix
  #   biologicalProcess: 
  #     GO: go.BP.id  ## HAS PREFIX (GO)
  #     ref_pmid: go.BP.pubmed
  #     ## commenting out because data-processing / biolink-modeling issues
  #     # evidence: go.BP.evidence  ## categorical variable?
  #     # go_qualifier: go.BP.qualifier  ## seems to be like a relation
  #   molecularFunction: 
  #     GO: go.MF.id  ## HAS PREFIX (GO)
  #     ref_pmid: go.MF.pubmed
  #     ## commenting out because data-processing / biolink-modeling issues
  #     # evidence: go.MF.evidence  ## categorical variable?
  #     # go_qualifier: go.MF.qualifier  ## seems to be like a relation
  #   cellularComponent: 
  #     GO: go.CC.id  ## HAS PREFIX (GO)
  #     ref_pmid: go.CC.pubmed
  #     ## commenting out because data-processing / biolink-modeling issues
  #     # evidence: go.CC.evidence  ## categorical variable?
  #     # go_qualifier: go.CC.qualifier  ## seems to be like a relation
  #   clingen: 
  #     MONDO: clingen.clinical_validity.mondo  ## HAS PREFIX (MONDO)
  #     source_url: clingen.clinical_validity.online_report
  #     ## commenting out because data-processing / biolink-modeling issues
  #     # ## possible values for classification: definitive, moderate, limited, disputed, refuted (!!!), no known disease relationship (!!!)
  #     # clingen_clinical_validity_classification: clingen.clinical_validity.classification  
  #   pantherMGI: 
  #     MGI: pantherdb.ortholog.MGI  ## no prefix
  #     ## commenting out because data-processing / biolink-modeling issues
  #     # inTaxon: pantherdb.ortholog.taxid
  #   pantherHGNC: 
  #     HGNC: pantherdb.HGNC  ## no prefix
