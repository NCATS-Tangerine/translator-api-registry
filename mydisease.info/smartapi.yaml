openapi: 3.0.3
info:
  contact:
    email: help@biothings.io
    name: Chunlei Wu
    x-id: https://github.com/newgene
    x-role: responsible developer
  description: Documentation of the MyDisease.info disease query web services.  Learn
    more about [MyDisease.info](https://docs.mydisease.info/en/latest/index.html)
  termsOfService: https://mydisease.info/terms
  title: MyDisease.info API
  version: '1.0'
  x-bte:
    batch_size_limit: 1000
    request_rate_limit: 5000
  x-translator:
    infores: "infores:mydisease-info"
    component: KP
    team:
      - Service Provider
    biolink-version: "4.2.2"
servers:
- description: Encrypted Production server
  url: https://mydisease.info/v1
  x-maturity: production
tags:
- name: disease
- name: annotation
- name: query
- name: translator
- name: x-bte
- name: biothings
paths:
  "/disease/{id}":
    get:
      description: >-
        By default, this will return the complete disease annotation object in JSON format. 
        See [here](https://docs.mydisease.info/en/latest/doc/data.html#disease-object)
        for more details. If the input disease ID is not valid, 404 (NOT FOUND) will be returned.
        

        Optionally, you can pass a "fields" parameter to return only the annotation you want 
        (by filtering returned object fields). "fields" accepts any attributes (a.k.a fields) available 
        from the disease object. Multiple attributes should be separated by commas. If an attribute is not 
        available for a specific disease object, it will be ignored. Note that the attribute names are 
        case-sensitive.


        Just like the disease query service, you can also pass a "callback" parameter to make a JSONP call.
      parameters:
      ## these are provided in the docs https://docs.mydisease.info/en/latest/doc/disease_annotation_service.html
      - name: id
        description: >-
          Retrieve disease data based on ID
        in: path
        required: true
        example: "MONDO:0000490"
        schema:
          type: string
      - "$ref": "#/components/parameters/fields"
      - "$ref": "#/components/parameters/callback"
      - "$ref": "#/components/parameters/email"
      ## this is useful even when it's not noted in the docs
      - "$ref": "#/components/parameters/size"
      ## these are noted in the https://mydisease.info/v1/spec endpoint; commenting out for now
      # - "$ref": "#/components/parameters/raw"
      # - "$ref": "#/components/parameters/rawquery"
      # - "$ref": "#/components/parameters/dotfield"
      # - "$ref": "#/components/parameters/_sorted"
      # - "$ref": "#/components/parameters/always_list"
      # - "$ref": "#/components/parameters/allow_null"
      # - "$ref": "#/components/parameters/format"
      responses:
        '200':
          ## description from https://docs.mydisease.info/en/latest/doc/response_status_codes.html
          description: A 200 status code indicates a successful query, and is accompanied by the query response payload.
      ## commenting out schemas and other status codes for now
      #     content:
      #       application/json:
      #         schema:
      #           $ref: '#/components/schemas/Disease'
      #   '404':
      #     description: A response indicating an unknown disease ID
      tags:
      - disease
  "/disease":
    post:
      description: >-
        Although making simple GET requests above to our disease query service is sufficient in most use cases, 
        there are some times you might find it easier to batch query (e.g., retrieving disease annotations for 
        multiple diseases). Fortunately, you can also make batch queries via POST requests when you need to.
      parameters:
      ## these are provided in the docs https://docs.mydisease.info/en/latest/doc/disease_annotation_service.html
      - name: ids
        description: >-
          Accepts multiple disease ids (e.g. MONDO or DO ids) separated by commas. 
          Note that currently we only take the input ids up to 1000 maximum, the rest will be omitted.


          The request body can also be used to provide these ids.
        in: query
        ## setting to false since putting this info in the request body seems to work as well
        required: false
        schema:
          type: string
      - "$ref": "#/components/parameters/fields"
      - "$ref": "#/components/parameters/email"
      ## this is useful even when it's not noted in the docs
      - "$ref": "#/components/parameters/size"
      ## these are noted in the https://mydisease.info/v1/spec endpoint; commenting out for now
      # - "$ref": "#/components/parameters/raw"
      # - "$ref": "#/components/parameters/rawquery"
      # - "$ref": "#/components/parameters/dotfield"
      # - "$ref": "#/components/parameters/_sorted"
      # - "$ref": "#/components/parameters/always_list"
      # - "$ref": "#/components/parameters/allow_null"
      # - "$ref": "#/components/parameters/format"
      requestBody:
        content:
          application/json:
            example:
              ids:
              - "MONDO:0000490"
              - "MONDO:0019012"
            schema:
              type: object
              properties:
                ids:
                  description: >-
                    Accepts multiple disease ids. Note that currently we only take the input ids 
                    up to 1000 maximum, the rest will be omitted.
                  type: array
                  items:
                    type: string
      responses:
        '200':
          description: A 200 status code indicates a successful query, and is accompanied by the query response payload.
      tags:
      - disease
  "/metadata":
    get:
      description: Get metadata about the data available from the API
      ## these are noted in the https://mydisease.info/v1/spec endpoint; commenting out for now
      # parameters:
      # - "$ref": "#/components/parameters/format"
      # - "$ref": "#/components/parameters/raw"
      responses:
        '200':
          description: A 200 status code indicates a successful query, and is accompanied by the query response payload.
      tags:
      - metadata
  "/metadata/fields":
    get:
      description: Get metadata about the data fields available from the API
      ## these are noted in the https://mydisease.info/v1/spec endpoint; commenting out for now
      # parameters:
      # - "$ref": "#/components/parameters/format"
      # - "$ref": "#/components/parameters/raw"
      # - "$ref": "#/components/parameters/search"
      # - "$ref": "#/components/parameters/prefix"
      responses:
        '200':
          description: A 200 status code indicates a successful query, and is accompanied by the query response payload.
      tags:
      - metadata
  "/query":
    get:
      description: >-
        MyDisease.info disease query web service. In the output, "total" in the output gives the total number 
        of matching hits, while the actual hits are returned under "hits" field.
      parameters:
      - name: q
        ## description partially from https://docs.mydisease.info/en/latest/doc/disease_query_service.html#query-syntax
        description: >-
          Required, passing user query. The detailed query syntax for parameter is explained 
          [here](https://docs.mydisease.info/en/latest/doc/disease_query_service.html#query-syntax).
        in: query
        required: true
        example: "cancer"
        schema:
          type: string
      - "$ref": "#/components/parameters/fields"
      - "$ref": "#/components/parameters/size"
      - "$ref": "#/components/parameters/from"
      - "$ref": "#/components/parameters/fetch_all"
      - "$ref": "#/components/parameters/scroll_id"
      - "$ref": "#/components/parameters/sort"
      - "$ref": "#/components/parameters/facets"
      - "$ref": "#/components/parameters/facet_size"
      - "$ref": "#/components/parameters/callback"
      - "$ref": "#/components/parameters/dotfield"
      - "$ref": "#/components/parameters/email"
      ## these are noted in the https://mydisease.info/v1/spec endpoint; commenting out for now
      # - "$ref": "#/components/parameters/aggs"
      # - "$ref": "#/components/parameters/userquery"
      # - "$ref": "#/components/parameters/explain"
      # - "$ref": "#/components/parameters/raw"
      # - "$ref": "#/components/parameters/rawquery"
      # - "$ref": "#/components/parameters/_sorted"
      # - "$ref": "#/components/parameters/always_list"
      # - "$ref": "#/components/parameters/allow_null"
      # - "$ref": "#/components/parameters/format"
      responses:
        '200':
          description: A 200 status code indicates a successful query, and is accompanied by the query response payload.
      ## commenting out schemas and other status codes for now
      #     content:
      #       application/json:
      #         schema:
      #           "$ref": "#/components/schemas/QueryResult"
      #   '400':
      #     content:
      #       application/json:
      #         schema:
      #           "$ref": "#/components/schemas/ErrorResult"
      #     description: A response indicating an improperly formatted query
      # description: Make queries and return matching gene hits. Supports JSONP and CORS
      #   as well.
      tags:
      - query
    post:
      description: >-
        Although making simple GET requests above to our disease query service is sufficient for most use cases, 
        there are times you might find it more efficient to make batch queries (e.g., retrieving disease annotation 
        for multiple diseases). Fortunately, you can also make batch queries via POST requests when you need to.


        The "query" field in the returned object indicates the matching query term. If a query term has no match, 
        it will return with a "notfound" field with the value "true".
      parameters:
      ## these are provided in the docs https://docs.mydisease.info/en/latest/doc/disease_query_service.html#id2
      - name: q
        description: >-
          Accepts multiple values separated by commas. Note that currently we only take the input values up to 1000 
          maximum, the rest will be omitted.


          The request body can also be used to provide these ids.
        in: query
        ## setting to false since putting this info in the request body seems to work as well
        required: false
        schema:
          type: array
          items:
            type: string
      - name: scopes
        description: >-
          Optional, specify one or more fields (separated by commas) to search. 
          The available "fields" can be passed to "scopes" parameter are listed 
          [here](https://docs.mydisease.info/en/latest/doc/data.html#available-fields). Default: _id


          The request body can also be used to provide this information.
        in: query
        ## setting to false since putting this info in the request body seems to work as well
        required: false
        schema:
          type: string
      - "$ref": "#/components/parameters/fields"
      - "$ref": "#/components/parameters/email"
      ## this is useful even when it's not noted in the docs
      - "$ref": "#/components/parameters/size"
      - "$ref": "#/components/parameters/from"
      - "$ref": "#/components/parameters/fetch_all"
      - "$ref": "#/components/parameters/scroll_id"
      ## these are noted in the https://mydisease.info/v1/spec endpoint; commenting out for now
      # - "$ref": "#/components/parameters/sort"
      # - "$ref": "#/components/parameters/raw"
      # - "$ref": "#/components/parameters/rawquery"
      # - "$ref": "#/components/parameters/dotfield"
      # - "$ref": "#/components/parameters/_sorted"
      # - "$ref": "#/components/parameters/always_list"
      # - "$ref": "#/components/parameters/allow_null"
      # - "$ref": "#/components/parameters/format"
      requestBody:
        content:
          application/json:
            example:
              q:
              - "MONDO:0000490"
              - "MONDO:0019012"
              scopes:
              - "mondo.mondo"
            schema:
              type: object
              properties:
                q:
                  description: >-
                    Accepts multiple values separated by commas. Note that currently we only take the input values 
                    up to 1000 maximum, the rest will be omitted.
                  type: array
                  items:
                    type: string
                scopes:
                  description: >-
                    Specify one or more fields (separated by commas) to search. 
                    The available "fields" can be passed to "scopes" parameter are listed 
                    [here](https://docs.mydisease.info/en/latest/doc/data.html#available-fields). Default: _id
                  type: array
                  items:
                    type: string
      responses:
        '200':
          description: A 200 status code indicates a successful query, and is accompanied by the query response payload.
      ## commenting out schemas and other status codes for now
      #     content:
      #       application/json:
      #         schema:
      #           "$ref": "#/components/schemas/QueryPOSTResult"
      #   '400':
      #     content:
      #       application/json:
      #         schema:
      #           "$ref": "#/components/schemas/ErrorResult"
      #     description: A response indicating an improperly formatted query
      # description: Make batch gene queries and return matching gene hits
      tags:
      - query
components:
  parameters:
    callback:
      name: callback
      description: >-
        Optional, you can pass a "callback" parameter to make a JSONP call.
      in: query
      required: false
      schema:
        type: string
    dotfield:
      name: dotfield
      description: >-
        Optional, can be used to control the format of the returned object. 
        If "dotfield" is true, the returned data object is returned flattened (no nested objects) 
        using dotfield notation for key names. Default: false.
      in: query
      required: false
      schema:
        type: boolean
        default: false
    email:
      name: email
      description: >-
        Optional, if you are regular users of our services, we encourage you to provide us an email, 
        so that we can better track the usage or follow up with you.
      in: query
      required: false
      schema:
        type: string
    facet_size:
      name: facet_size
      description: >-
        Optional, an integer (1 <= facet_size <= 1000) that specifies how many buckets to return in a 
        [faceted query](https://docs.mydisease.info/en/latest/doc/disease_query_service.html?highlight=from#faceted-queries).
      in: query
      required: false
      schema:
        type: integer
        default: 10
    facets:
      name: facets
      description: >-
        Optional, a single field or comma-separated fields to return facets, can only be used on non-free text fields. 
        E.g. "facets=disgenet.genes_related_to_disease.YearFinal". See [examples of faceted queries 
        here](https://docs.mydisease.info/en/latest/doc/disease_query_service.html?highlight=from#faceted-queries).
      in: query
      required: false
      schema:
        type: array
        items:
          type: string
    fetch_all:
      name: fetch_all
      description: >-
        Optional, a boolean, which when TRUE, allows fast retrieval of all unsorted query hits. 
        The return object contains a _scroll_id field, which when passed as a parameter to the query endpoint 
        (see the scroll_id parameter), returns the next 1000 query results. Setting fetch_all = TRUE causes 
        the results to be inherently unsorted, therefore the sort parameter is ignored. For more information, 
        see [examples using fetch_all 
        here](https://docs.mydisease.info/en/latest/doc/disease_query_service.html?highlight=from#scrolling-queries). 
        Default: FALSE.
      in: query
      required: false
      schema:
        type: boolean
        default: false
    fields:
      name: fields
      description: >-
        Optional, can be a comma-separated list to limit the fields returned from the object. 
        If "fields=all", all available fields will be returned. Look 
        [here](https://docs.mydisease.info/en/latest/doc/data.html#available-fields) for a list of available fields. 
        

        Note that it supports dot notation as well, e.g., you can pass "chebi.name". 
        Default: "fields=all". 
        The parameter "filter" is an alias for this parameter.
      in: query
      required: false
      schema:
        type: string
        default: all
    from:
      name: from
      description: >-
        Optional, the number of matching hits to skip, starting from 0. Default: 0. 
      in: query
      required: false
      schema:
        type: integer
        default: 0
    scroll_id:
      name: scroll_id
      description: >-
        Optional, a string containing the _scroll_id returned from a query request with fetch_all = TRUE. 
        Supplying a valid scroll_id will return the next 1000 unordered results. If the next results are 
        not obtained within 1 minute of the previous set of results, the scroll_id becomes stale, and a 
        new one must be obtained with another query request with fetch_all = TRUE. All other parameters are 
        ignored when the scroll_id parameter is supplied. For more information see [examples using scroll_id 
        here](https://docs.mydisease.info/en/latest/doc/disease_query_service.html?highlight=from#scrolling-queries).
      in: query
      required: false
      schema:
        type: string
    size:
      name: size
      description: >-
        Optional, the maximum number of matching hits to return (with a cap of 1000 at the moment). Default: 10.
        The combination of "size" and "from" parameters can be used to get paging for a large query.
      in: query
      required: false
      schema:
        type: integer
        default: 10
    sort:
      name: sort
      description: >-
        Optional, the comma-separated fields to sort on. Prefix with "-" for descending order, otherwise in ascending order. 
        Default: sort by matching scores in descending order.
      in: query
      required: false
      schema:
        type: array
        items:
          type: string
    ## these are noted in the https://mydisease.info/v1/spec endpoint; commenting out for now
    # _sorted:
    #   name: _sorted
    #   in: query
    #   required: false
    #   schema:
    #     type: boolean
    #     default: true
    # aggs:
    #   name: aggs
    #   in: query
    #   required: false
    #   schema:
    #     type: array
    #     items:
    #       type: string
    # allow_null:
    #   name: allow_null
    #   in: query
    #   required: false
    #   schema:
    #     type: array
    #     items:
    #       type: string
    # always_list:
    #   name: always_list
    #   in: query
    #   required: false
    #   schema:
    #     type: array
    #     items:
    #       type: string
    # explain:
    #   name: explain
    #   in: query
    #   required: false
    #   schema:
    #     type: boolean
    # format:
    #   name: format
    #   description: 'controls output format of server response, currently supports:
    #     "json", "jsonld", "html". Type: string. Default: json.'
    #   in: query
    #   required: false
    #   schema:
    #     type: string
    #     default: json
    # prefix:
    #   name: prefix
    #   in: query
    #   required: false
    #   schema:
    #     type: string
    # raw:
    #   name: raw
    #   in: query
    #   required: false
    #   schema:
    #     type: boolean
    # rawquery:
    #   name: rawquery
    #   in: query
    #   required: false
    #   schema:
    #     type: boolean
    # search:
    #   name: search
    #   in: query
    #   required: false
    #   schema:
    #     type: string
    # userquery:
    #   name: userquery
    #   in: query
    #   required: false
    #   schema:
    #     type: string
  ## commenting out schemas and other status codes for now
  # schemas:
  #   Chem:
  #     properties:
  #       _id:
  #         type: string
  #     required:
  #     - _id
  #     type: object
  #   ErrorResult:
  #     properties:
  #       message:
  #         type: string
  #       success:
  #         type: boolean
  #     type: object
  #   QueryPOSTResult:
  #     items:
  #       allOf:
  #       - "$ref": "#/components/schemas/Disease"
  #       - properties:
  #           _score:
  #             format: float
  #             type: number
  #           query:
  #             type: string
  #         type: object
  #     type: array
  #   QueryResult:
  #     properties:
  #       hits:
  #         items:
  #           "$ref": "#/components/schemas/Disease"
  #         type: array
  #       max_score:
  #         format: float
  #         type: number
  #       took:
  #         type: integer
  #       total:
  #         type: integer
  #     type: object
  #   int64_or_array:
  #     oneOf:
  #     - items:
  #         format: int64
  #         type: integer
  #       type: array
  #     - format: int64
  #       type: integer
  #   string_or_array:
  #     oneOf:
  #     - items:
  #         type: string
  #       type: array
  #     - type: string
#   x-bte-response-mapping:
#     ## not including "name" field since BTE isn't ingesting / using it to annotate nodes...
#     disease-gene:
#       NCBIGene: disgenet.genes_related_to_disease.gene_id  ## no prefix
#       ref_pmid: disgenet.genes_related_to_disease.pubmed     ## no prefix
#       ## commenting out because data-processing / biolink-modeling issues
#       # disgenet_source: disgenet.genes_related_to_disease.source
#       # ## could remove "disgenet-" prefix from the key
#       # ##  if the key becomes the TRAPI attribute "original_attribute_name"
#       # disgenet-DPI: disgenet.genes_related_to_disease.DPI
#       # disgenet-DSI: disgenet.genes_related_to_disease.DSI
#       # disgenet-EI: disgenet.genes_related_to_disease.EI
#       # disgenet-score: disgenet.genes_related_to_disease.score
#     disease-variant:
#       DBSNP: disgenet.variants_related_to_disease.rsid       ## no prefix
#       ref_pmid: disgenet.variants_related_to_disease.pubmed    ## no prefix
#       ## commenting out because data-processing / biolink-modeling issues
#       # disgenet_source: disgenet.variants_related_to_disease.source
#       # ## could remove "disgenet-" prefix from the key
#       # ##  if the key becomes the TRAPI attribute "original_attribute_name"
#       # disgenet-DPI: disgenet.variants_related_to_disease.DPI
#       # disgenet-DSI: disgenet.variants_related_to_disease.DSI
#       # disgenet-EI: disgenet.variants_related_to_disease.EI
#       # disgenet-score: disgenet.variants_related_to_disease.score
#     disease-chemical:
#       MESH: ctd.chemical_related_to_disease.mesh_chemical_id    ## no prefix
#       ref_pmid: ctd.chemical_related_to_disease.pubmed     ## no prefix
#       ## commenting out because data-processing / biolink-modeling issues
#       # # name: ctd.chemical_related_to_disease.chemical_name
#       # ## direct_evidence has two values, 'marker/mechanism' or 'therapeutic'
#       # ctd_evidence_type: ctd.chemical_related_to_disease.direct_evidence
#     gene-disease:
#       UMLS: disgenet.xrefs.umls     ## no prefix
#       ref_pmid: disgenet.genes_related_to_disease.pubmed     ## no prefix
#     variant-disease:
#       UMLS: disgenet.xrefs.umls     ## no prefix
#       ref_pmid: disgenet.variants_related_to_disease.pubmed     ## no prefix
#     omim:
#       OMIM: hpo.omim  ## no prefix
#     orphanet:
#       orphanet: hpo.orphanet  ## no prefix
#     mondo:  ## added for a bunch of operations
#       MONDO: mondo.mondo  ## HAS PREFIX (MONDO)
#     ctd-mesh-disease:  ## added for chemical-disease operation
#       MESH: ctd.mesh  ## no prefix
#     ctd-omim-disease:  ## added for chemical-disease2 operation
#       OMIM: ctd.omim  ## no prefix
#     has_subclass:
#       MONDO: mondo.children    ## HAS PREFIX (MONDO)
#     subclass_of:
#       MONDO: mondo.parents    ## HAS PREFIX (MONDO)
#     predisposes_towards:
#       MONDO: mondo.predisposes_towards.mondo    ## HAS PREFIX (MONDO)
#     disease_shares_features_of:
#       MONDO: mondo.disease_shares_features_of.mondo    ## HAS PREFIX (MONDO)
#     disease_has_major_feature:
#       MONDO: mondo.disease_has_major_feature.mondo    ## HAS PREFIX (MONDO)
#     disease_has_feature:
#       MONDO: mondo.disease_has_feature.mondo    ## HAS PREFIX (MONDO)
#     disease_causes_feature:
#       MONDO: mondo.disease_causes_feature.mondo    ## HAS PREFIX (MONDO)
#     disease_arises_from_feature:
#       MONDO: mondo.disease_arises_from_feature.mondo    ## HAS PREFIX (MONDO)
  x-bte-defs:
    hpo-parameters:
      fields: >-
        hpo.phenotype_related_to_disease.hpo_id,
        hpo.omim,hpo.orphanet,
        hpo.phenotype_related_to_disease.pmid_refs,
        hpo.phenotype_related_to_disease.isbn_refs,
        hpo.phenotype_related_to_disease.website_refs,
        hpo.phenotype_related_to_disease.numeric_freq,
        hpo.phenotype_related_to_disease.hp_freq,
        hpo.phenotype_related_to_disease.freq_numerator,
        hpo.phenotype_related_to_disease.freq_denominator
      size: 100      ## should be overestimate, shouldn't get 1 disease ID -> 100 disease documents
  x-bte-annotations:
#   ## NOTES:
#   ## - could use jmespath to create more specific operations based on disgenet's `source` field values 
#   ##   this could include more specific source, KL/AT, maybe predicate/qualifier 
#   ## - we used disgenet data files that don't have the specific relationship terms mentioned in the resource's documentation
#     disease-gene:
#     ## 22499 / 27312 disgenet.genes_related_to_disease records have disgenet.xrefs.umls
#     ## https://mydisease.info/v1/query?q=_exists_:disgenet.genes_related_to_disease%20AND%20_exists_:disgenet.xrefs.umls
#     ## 9051 / 22499 diseases have a gene with score >=0.3 
#     ## https://mydisease.info/v1/query?q=disgenet.genes_related_to_disease.score:%3E=0.3%20AND%20_exists_:disgenet.xrefs.umls&fields=disgenet
#       - supportBatch: true
#         useTemplating: true
#         inputs:
#         - id: UMLS
#           semantic: Disease
#         requestBody:
#           body:
#             ## currently, BTE already strips prefix...
#             q: "{{ queryInputs }}"  ## no prefix
#             scopes: disgenet.xrefs.umls
#         outputs:
#         - id: NCBIGene
#           semantic: Gene
#         parameters:
#         ## see https://www.disgenet.org/dbinfo#section44
#         ## not including YearFinal, YearInitial, gene_name 
#         ## commenting out because data-processing / biolink-modeling issues
#           # fields: >- 
#           #   disgenet.genes_related_to_disease.gene_id,
#           #   disgenet.genes_related_to_disease.pubmed,
#           #   disgenet.genes_related_to_disease.source,
#           #   disgenet.genes_related_to_disease.DPI,
#           #   disgenet.genes_related_to_disease.DSI,
#           #   disgenet.genes_related_to_disease.EI,
#           #   disgenet.genes_related_to_disease.score
#           fields: disgenet.genes_related_to_disease   ## need the whole thing for jmespath to work
#           ## only want records where at <=1 array element has score >= 0.3
#           filter: disgenet.genes_related_to_disease.score:>=0.3
#           jmespath: disgenet.genes_related_to_disease|[?score>=`0.3`]
#           ## just in case: I haven't come across a document with 1 object to see if it's in a single-element array or not
#           always_list: disgenet.genes_related_to_disease
#         predicate: condition_associated_with_gene 
#         source: "infores:disgenet"
#         knowledge_level: knowledge_assertion
#         agent_type: automated_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/disease-gene"
#         testExamples:
#         ## score >= 0.3
#           - qInput: "UMLS:C0014805"       ## Primary Erythermalgia / MONDO:0007571 
#             oneOutput: "NCBIGene:6336"    ## SCN10A
#           - qInput: "UMLS:C0157743"       ## Vibratory urticaria / MONDO:0006618
#             oneOutput: "NCBIGene:30817"   ## ADGRE2
#     disease-variant:
#     ## 10939 / 12343 disgenet.variants_related_to_disease records have disgenet.xrefs.umls
#     ## https://mydisease.info/v1/query?q=_exists_:disgenet.variants_related_to_disease%20AND%20_exists_:disgenet.xrefs.umls
#     ## 8407 / 10939 diseases have a variant with score >=0.3 
#     ## https://mydisease.info/v1/query?q=disgenet.variants_related_to_disease.score:%3E=0.3%20AND%20_exists_:disgenet.xrefs.umls&fields=disgenet
#       - supportBatch: true
#         useTemplating: true
#         inputs:
#         - id: UMLS
#           semantic: Disease
#         requestBody:
#           body:
#             q: "{{ queryInputs }}"  ## no prefix
#             scopes: disgenet.xrefs.umls
#         outputs:
#         - id: DBSNP
#           semantic: SequenceVariant
#         parameters:
#         ## see https://www.disgenet.org/dbinfo#section45
#         ## not including YearFinal, YearInitial, chrom, pos 
#         ## commenting out because data-processing / biolink-modeling issues
#           # fields: >- 
#           #   disgenet.variants_related_to_disease.rsid,
#           #   disgenet.variants_related_to_disease.pubmed,
#           #   disgenet.variants_related_to_disease.source,
#           #   disgenet.variants_related_to_disease.DPI,
#           #   disgenet.variants_related_to_disease.DSI,
#           #   disgenet.variants_related_to_disease.EI,
#           #   disgenet.variants_related_to_disease.score
#           fields: disgenet.variants_related_to_disease
#           filter: disgenet.variants_related_to_disease.score:>=0.3
#           jmespath: disgenet.variants_related_to_disease|[?score>=`0.3`]
#           ## needed for jmespath to work, because sometimes the value of this field is an object and sometimes an array of objects
#           always_list: disgenet.variants_related_to_disease
#         predicate: related_to
#         source: "infores:disgenet"
#         knowledge_level: knowledge_assertion
#         agent_type: automated_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/disease-variant"
#         testExamples:
#           - qInput: "UMLS:C0263912"             ## Rotator cuff syndrome / MONDO:0007028
#             oneOutput: "DBSNP:rs12527089"    
#           - qInput: "UMLS:C0346072"             ## Blue rubber bleb nevus syndrome / OMIM:112200
#             oneOutput: "DBSNP:rs1557497881"     
  ## for hpo-annotation-based operations:
  ## 10450 diseases/records have hpo.phenotype_related_to_disease.hpo_id field https://mydisease.info/v1/query?q=_exists_:hpo.phenotype_related_to_disease.hpo_id
  ## hpo.phenotype_related_to_disease includes annotations with aspect == "P"
  ##   (aspect as "I" became hpo.inheritance, "C" became hpo.course, "M" became hpo.modifier)
  ## Disease ID field: use hpo.omim, orphanet, decipher. Every record has >=1 of those fields https://mydisease.info/v1/query?q=_exists_:hpo.phenotype_related_to_disease.hpo_id%20AND%20(_exists_:hpo.omim%20OR%20_exists_:hpo.orphanet%20OR%20_exists_:hpo.decipher)
  ## - VS 75 records don't have mondo.mondo (mapping): all decipher records, a few omim, a few orphanet
  ##   https://mydisease.info/v1/query?q=_exists_:hpo.phenotype_related_to_disease.hpo_id%20AND%20NOT%20_exists_:mondo.mondo
  ## - 2102 records have hpo.omim and hpo.orphanet fields: https://mydisease.info/v1/query?q=_exists_:hpo.phenotype_related_to_disease.hpo_id%20AND%20%20_exists_:hpo.omim%20AND%20_exists_:hpo.orphanet
  ##   Because when hpo.omim and hpo.orphanet map to same mondo ID, their data is merged into same record
  ## - no operations for DECIPHER right now: no support in SRI NodeNorm 
    disease-phenotype:
    ## NO PAGINATION: 1 disease won't match >~1000 disease documents
      response_root: 'hpo.phenotype_related_to_disease.{"query": %.%.query, "disease_omim": %.omim, "disease_orphanet": %.orphanet, "phenotype_related_to_disease": $}'
      inputs:
        category: Disease
        ## do default `use_all_namespaces: false` behavior: for each entity, only use IDs from 1 namespace (the first one in list it has IDs for)
        ## data from synonymous OMIM/orphanet IDs have already been merged, so either ID can be used to retrieve the data 
        namespaces: 
        ## namespaces are ordered from most to least preferred (more documents have omim field)
        ## don't need name fields since SRI NodeNorm should be able to provide them
          - prefix: OMIM
            match_field: query
          - prefix: orphanet
            match_field: query
      predicate: has_phenotype
      outputs:
        category: PhenotypicFeature
        namespaces: 
          - prefix: HP
            id_field: phenotype_related_to_disease.hpo_id   ## single ID, has prefix
      request_info:
        path: "/query"   ## use same format that paths section does
        method: post     ## use same format that paths section does (lower case)
        support_batch: true
        ## must have separate requests for OMIM and orphanet IDs because their field's values have the same format (numeric ID only, no prefix)
        by_input_namespace:
          OMIM:
            request_body:
              q: "{{ input_ids }}"
              scopes: hpo.omim
            ## using $ref to make less repetitive
            parameters:
              "$ref": "#/components/x-bte-defs/hpo-parameters"
          orphanet:
            request_body:
              q: "{{ input_ids }}"
              scopes: hpo.orphanet
            parameters:
              "$ref": "#/components/x-bte-defs/hpo-parameters"
      provenance:   ## static format
      ## - hard to break into OMIM vs orphanet source because no field whose value is keyword specifying source 
      ## - hpo.phenotypes_related_to_disease.evidence values -> diff KL/AT values? But would need to know all possible values...
        knowledge_level: knowledge_assertion
        agent_type: manual_agent
        sources:
          - id: "infores:hpo-annotations"
            role: primary_knowledge_source
      response_mapping:
        ## has prefix 
        ref_pmid: phenotype_related_to_disease.pmid_refs    ## HAS PREFIX (PMID)
        ref_isbn: phenotype_related_to_disease.isbn_refs    ## HAS PREFIX (ISBN)
        ref_url: phenotype_related_to_disease.website_refs
        ## Translator validator sometimes complains about these attribute_type_ids
        ## needs debugging later
        "biolink:has_quotient": phenotype_related_to_disease.numeric_freq     ## decimal freq
        "biolink:frequency_qualifier": phenotype_related_to_disease.hp_freq   ## HP ontology freq term
        "biolink:has_count": phenotype_related_to_disease.freq_numerator      ## frequency as a fraction (numerator)
        "biolink:has_total": phenotype_related_to_disease.freq_denominator    ## frequency as a fraction (denominator)
      test_examples:
        - input_curie: "OMIM:246900"     ## Dihydrolipoamide Dehydrogenase Deficiency
          output_curie: "HP:0001254"     ## Lethargy
        - input_curie: "orphanet:881"    ## Turner Syndrome
          output_curie: "HP:0000137"     ## Abnormality of the ovary
#   ## for ctd-based operations:
#   ## Disease <-> chemical: 3356 diseases/records 
#   ## - knowledge_level / agent_type: parser removes all inferred annotations for disease-chemical
#   ## - Disease ID field: use ctd.mesh, ctd.omim. Every record either has one or the other https://mydisease.info/v1/query?q=_exists_:ctd.chemical_related_to_disease%20AND(%20_exists_:ctd.mesh%20OR%20_exists_:ctd.omim)
#   ##   - 1106 records don't have the mondo field (mapping): https://mydisease.info/v1/query?q=_exists_:ctd.chemical_related_to_disease%20AND%20NOT%20_exists_:mondo.mondo
#   ## - parser has a step where resource IDs (MESH, OMIM) are mapped to MONDO. 
#   ##   If multiple IDs map to the same MONDO, it's possible data is being overwritten https://github.com/biothings/mydisease.info/issues/59
#   ## - From what I can tell, CTD does their own entity resolution. 
#   ##   If a disease has MESH and OMIM IDs, the raw data has its info under the MESH ID only. 
#   ##   The OMIM ID is only used as the main disease ID if there isn't a matching MESH ID
#   ## Others:
#   ## - we wanted to add CTD direct disease-gene data, operations
#   ## - we removed CTD disease-pathway data because that info is all indirect
#     disease-chemical:
#       - supportBatch: true
#         useTemplating: true
#         inputs:
#         - id: MESH
#           semantic: Disease
#         requestBody:
#           body:
#             ## currently, BTE already strips prefix...
#             # q: "{{ queryInputs | rmPrefix }}"
#             q: "{{ queryInputs }}"  ## no prefix
#             scopes: ctd.mesh
#         outputs:
#         - id: MESH
#           semantic: SmallMolecule
#           ## note that 3085 / 3253 have cas_registry_number field that can be used as well
#         parameters:
#         ## not including: cas_registry_number, source, name
#         ## BTE currently isn't ingesting name correctly
#         ## commenting out because data-processing / biolink-modeling issues
#           # fields: >-
#           #   ctd.chemical_related_to_disease.mesh_chemical_id,
#           #   ctd.chemical_related_to_disease.direct_evidence,
#           #   ctd.chemical_related_to_disease.pubmed
#           fields: >-
#             ctd.chemical_related_to_disease.mesh_chemical_id,
#             ctd.chemical_related_to_disease.pubmed
#         predicate: related_to
#         ## direct_evidence is kinda like a relation....
#         ##   can have value "marker/mechanism" or "therapeutic").
#         source: "infores:ctd"
#         knowledge_level: knowledge_assertion
#         agent_type: manual_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/disease-chemical"
#         testExamples:
#           - qInput: "MESH:D009102"    ## Multiple Organ Failure
#             oneOutput: "MESH:C448659"   ## Geldanamycin, monohydrochloride
#     disease-chemical2:
#       - supportBatch: true
#         useTemplating: true
#         inputs:
#         - id: OMIM
#           semantic: Disease
#         requestBody:
#           body:
#             ## currently, BTE already strips prefix...
#             # q: "{{ queryInputs | rmPrefix }}"
#             q: "{{ queryInputs }}"  ## no prefix
#             scopes: ctd.omim
#         outputs:
#         - id: MESH
#           semantic: SmallMolecule
#         parameters:
#         ## commenting out because data-processing / biolink-modeling issues
#           # fields: >-
#           #   ctd.chemical_related_to_disease.mesh_chemical_id,
#           #   ctd.chemical_related_to_disease.direct_evidence,
#           #   ctd.chemical_related_to_disease.pubmed
#           fields: >-
#             ctd.chemical_related_to_disease.mesh_chemical_id,
#             ctd.chemical_related_to_disease.pubmed
#         predicate: related_to
#         source: "infores:ctd"
#         knowledge_level: knowledge_assertion
#         agent_type: manual_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/disease-chemical"
#         testExamples:
#           - qInput: "OMIM:613290"       ## hearing loss, cisplatin-induced, susceptibility to
#             oneOutput: "MESH:D002945"   ## Cisplatin
# ##########################################################################
# ## with "reverse" querying, non-batch querying with jmespath/jmespath_exclude_empty 
# ## is needed to retrieve only the queried ID's data subset within the disease's record
#     gene-disease:
#     ## 22499 / 27312 disgenet.genes_related_to_disease records have disgenet.xrefs.umls
#     ## https://mydisease.info/v1/query?q=_exists_:disgenet.genes_related_to_disease%20AND%20_exists_:disgenet.xrefs.umls
#     ## 9051 / 22499 diseases have a gene with score >=0.3 
#     ## https://mydisease.info/v1/query?q=disgenet.genes_related_to_disease.score:%3E=0.3%20AND%20_exists_:disgenet.xrefs.umls&fields=disgenet
#       - supportBatch: false
#         useTemplating: true
#         inputs:
#         - id: NCBIGene
#           semantic: Gene
#         requestBody:
#           body:
#             ## currently, BTE already strips prefix...
#             q: "{{ queryInputs }}"   ## no prefix
#             scopes: disgenet.genes_related_to_disease.gene_id
#         outputs:
#         - id: UMLS
#           semantic: Disease
#         parameters:
#           ## need the whole thing for jmespath to work
#           fields: disgenet.xrefs.umls,disgenet.genes_related_to_disease 
#           size: 1000  ## note the size limit
#           ## only want records where at <=1 array element has score >= 0.3 and output ID field exists
#           filter: disgenet.genes_related_to_disease.score:>=0.3 AND _exists_:disgenet.xrefs.umls
#           ## only keep the data that matches the gene_id value: use `` because ID is a number
#           jmespath: "disgenet.genes_related_to_disease|[?score>=`0.3` && gene_id==`{{ queryInputs }}`]"
#           ## needed for jmespath to work: only keep array elements that meet both criteria
#           jmespath_exclude_empty: true  
#           ## just in case: I haven't come across a document with 1 object to see if it's in a single-element array or not
#           always_list: disgenet.genes_related_to_disease
#         predicate: gene_associated_with_condition
#         source: "infores:disgenet"
#         knowledge_level: knowledge_assertion
#         agent_type: automated_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/gene-disease"
#         testExamples:
#           - qInput: "NCBIGene:1260"       ## CNGA2
#             oneOutput: "UMLS:C0393778"    ## Congenital anosmia / MONDO:0007137 isolated congenital anosmia
#           - qInput: "NCBIGene:161582"     ## DNAAF4
#             oneOutput: "UMLS:C0476254"    ## Dyslexia / MONDO:0001697
#     variant-disease:
#     ## 10939 / 12343 disgenet.variants_related_to_disease records have disgenet.xrefs.umls
#     ## https://mydisease.info/v1/query?q=_exists_:disgenet.variants_related_to_disease%20AND%20_exists_:disgenet.xrefs.umls
#     ## 8407 / 10939 diseases have a variant with score >=0.3 
#     ## https://mydisease.info/v1/query?q=disgenet.variants_related_to_disease.score:%3E=0.3%20AND%20_exists_:disgenet.xrefs.umls&fields=disgenet
#       - supportBatch: false
#         useTemplating: true
#         inputs:
#         - id: DBSNP
#           semantic: SequenceVariant
#         requestBody:
#           body:
#             ## currently, BTE already strips prefix...
#             q: "{{ queryInputs }}"   ## no prefix
#             scopes: disgenet.variants_related_to_disease.rsid
#         outputs:
#         - id: UMLS
#           semantic: Disease
#         parameters:
#           fields: disgenet.xrefs.umls,disgenet.variants_related_to_disease 
#           size: 1000  ## note the size limit
#           ## only want records where at <=1 array element has score >= 0.3 and output ID field exists
#           filter: disgenet.variants_related_to_disease.score:>=0.3 AND _exists_:disgenet.xrefs.umls
#           ## only keep the data that matches the rsid value
#           jmespath: "disgenet.variants_related_to_disease|[?score>=`0.3` && rsid=='{{ queryInputs }}']"
#           ## needed for jmespath to work: only keep array elements that meet both criteria
#           jmespath_exclude_empty: true  
#           ## needed for jmespath to work, because sometimes the value of this field is an object and sometimes an array of objects
#           always_list: disgenet.variants_related_to_disease
#         predicate: related_to
#         source: "infores:disgenet"
#         knowledge_level: knowledge_assertion
#         agent_type: automated_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/variant-disease"
#         testExamples:
#           - qInput: "DBSNP:rs78655421"
#             oneOutput: "UMLS:C0010674"    ## Cystic Fibrosis / MONDO:0009061
#           - qInput: "DBSNP:rs1032507"
#             oneOutput: "UMLS:C1863416"    ## Achoo syndrome MONDO:0007038 (Autosomal dominant compelling helio ophthalmic outburst syndrome)
#     phenotype-disease:
#       - supportBatch: true
#         useTemplating: true
#         inputs:
#         - id: HP
#           semantic: PhenotypicFeature
#         requestBody:
#           body:
#             ## HAS PREFIX (HP): currently a bit redundant to do this (BTE handles it)
#             # q: "{{ queryInputs | replPrefix('HP', ':') }}"
#             q: "{{ queryInputs }}"
#             scopes: hpo.phenotype_related_to_disease.hpo_id
#         outputs:
#         - id: OMIM
#           semantic: Disease
#         parameters:
#           fields: hpo.omim
#           size: 1000  ## note the size limit
#         predicate: phenotype_of
#         source: "infores:hpo-annotations"
#         knowledge_level: knowledge_assertion
#         agent_type: manual_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/omim"
#         testExamples:
#           - qInput: "HP:0000224"       ## Hypogeusia
#             oneOutput: "OMIM:201300"   ## Neuropathy, hereditary sensory and autonomic, type II
#     phenotype-disease2:
#       - supportBatch: true
#         useTemplating: true
#         inputs:
#         - id: HP
#           semantic: PhenotypicFeature
#         requestBody:
#           body:
#             ## HAS PREFIX (HP): currently a bit redundant to do this (BTE handles it)
#             # q: "{{ queryInputs | replPrefix('HP', ':') }}"
#             q: "{{ queryInputs }}"
#             scopes: hpo.phenotype_related_to_disease.hpo_id
#         outputs:
#         - id: orphanet
#           semantic: Disease
#         parameters:
#           fields: hpo.orphanet
#           size: 1000  ## note the size limit
#         predicate: phenotype_of
#         source: "infores:hpo-annotations"
#         knowledge_level: knowledge_assertion
#         agent_type: manual_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/orphanet"
#         testExamples:
#           - qInput: "HP:0000224"          ## Hypogeusia
#             oneOutput: "orphanet:99857"   ## Secondary Syringomyelia
#     chemical-disease:
#       - supportBatch: true
#         useTemplating: true
#         inputs:
#         - id: MESH
#           semantic: SmallMolecule
#         requestBody:
#           body:
#             ## currently, BTE already strips prefix...
#             # q: "{{ queryInputs | rmPrefix }}"
#             q: "{{ queryInputs }}"  ## no prefix
#             scopes: ctd.chemical_related_to_disease.mesh_chemical_id
#         outputs:
#         - id: MESH
#           semantic: Disease
#         parameters:
#           fields: ctd.mesh
#           size: 1000  ## note the size limit
#         predicate: related_to
#         source: "infores:ctd"
#         knowledge_level: knowledge_assertion
#         agent_type: manual_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/ctd-mesh-disease"
#         testExamples:
#           - qInput: "MESH:D000655"      ## Amodiaquine
#             oneOutput: "MESH:D008288"   ## Malaria (maps to MONDO:0005136)
#     chemical-disease2:
#       - supportBatch: true
#         useTemplating: true
#         inputs:
#         - id: MESH
#           semantic: SmallMolecule
#         requestBody:
#           body:
#             ## currently, BTE already strips prefix...
#             # q: "{{ queryInputs | rmPrefix }}"
#             q: "{{ queryInputs }}"    ## no prefix
#             scopes: ctd.chemical_related_to_disease.mesh_chemical_id
#         outputs:
#         - id: OMIM
#           semantic: Disease
#         parameters:
#           fields: ctd.omim
#           size: 1000  ## note the size limit
#         predicate: related_to
#         source: "infores:ctd"
#         knowledge_level: knowledge_assertion
#         agent_type: manual_agent
#         response_mapping: 
#           "$ref": "#/components/x-bte-response-mapping/ctd-omim-disease"  
#         testExamples:
#           - qInput: "MESH:D000655"     ## Amodiaquine
#             oneOutput: "OMIM:248310"   ## PLASMODIUM FALCIPARUM BLOOD INFECTION LEVEL (maps to MONDO:0009553)
# ############################################################################
#     ## - there's also disease_ontology info (ancestors, children, descendants, parents)
#     ## - there's also mondo info (ancestors, descendants)
#     ## - mondo info we're not including:
#     ##     - do we want to keep or remove parent/children relationships?
#     ##     - part_of_progression_of_disease (only 2 disease-disease relationships)
#     ##     - has_modifier (something is off here, shouldn't be mondo prefix...)
#     ##     - excluded_subClassOf (something is off here, I'm not sure what that means)
#     ##     - disjoint from (this is a negation / NOT relationship)
#     has_subclass:
#       - supportBatch: true
#         useTemplating: true
#         inputs:
#         - id: MONDO
#           semantic: Disease
#         requestBody:
#           body:
#             ## HAS PREFIX (MONDO): currently a bit redundant to do this (BTE handles it)
#             # q: "{{ queryInputs | replPrefix('MONDO', ':') }}"
#             q: "{{ queryInputs }}"
#             scopes: mondo.mondo
#         outputs:
#         - id: MONDO
#           semantic: Disease
#         parameters:
#           fields: mondo.children
#           size: 1000  ## note the size limit
#         predicate: superclass_of  ## this is the inverse of subclass_of right now
#         ## relation: "has children"?
#         source: "infores:mondo"
#         knowledge_level: knowledge_assertion
#         agent_type: manual_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/has_subclass"
#         testExamples:
#           - qInput: "MONDO:0002494"      ## substance-related disorder
#             oneOutput: "MONDO:0021698"   ## alcohol-related disorders          
#     subclass_of:
#       - supportBatch: true
#         useTemplating: true
#         inputs:
#         - id: MONDO
#           semantic: Disease
#         requestBody:
#           body:
#             ## HAS PREFIX (MONDO): currently a bit redundant to do this (BTE handles it)
#             # q: "{{ queryInputs | replPrefix('MONDO', ':') }}"
#             q: "{{ queryInputs }}"
#             scopes: mondo.mondo
#         outputs:
#         - id: MONDO
#           semantic: Disease
#         parameters:
#           fields: mondo.parents
#           size: 1000  ## note the size limit
#         predicate: subclass_of
#         ## relation: "has parents"?
#         source: "infores:mondo"
#         knowledge_level: knowledge_assertion
#         agent_type: manual_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/subclass_of"
#         testExamples:
#           - qInput: "MONDO:0002494"      ## substance-related disorder
#             oneOutput: "MONDO:0002025"   ## psychiatric disorder
#     predisposes_towards:
#       - supportBatch: true
#         useTemplating: true
#         inputs:
#         - id: MONDO
#           semantic: Disease
#         requestBody:
#           body:
#             ## HAS PREFIX (MONDO): currently a bit redundant to do this (BTE handles it)
#             # q: "{{ queryInputs | replPrefix('MONDO', ':') }}"
#             q: "{{ queryInputs }}"
#             scopes: mondo.mondo
#         outputs:
#         - id: MONDO
#           semantic: Disease
#         parameters:
#           fields: mondo.predisposes_towards.mondo
#           size: 1000  ## note the size limit
#         predicate: contributes_to  ## maps to "MONDO:predisposes_towards"
#         source: "infores:mondo"
#         knowledge_level: knowledge_assertion
#         agent_type: manual_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/predisposes_towards"
#         testExamples:
#           - qInput: "MONDO:0010940"      ## inherited susceptibility to asthma
#             oneOutput: "MONDO:0004979"   ## asthma
#     predisposes_towards-rev:
#       - supportBatch: true
#         useTemplating: true
#         inputs:
#         - id: MONDO
#           semantic: Disease
#         requestBody:
#           body:
#             ## HAS PREFIX (MONDO): currently a bit redundant to do this (BTE handles it)
#             # q: "{{ queryInputs | replPrefix('MONDO', ':') }}"
#             q: "{{ queryInputs }}"
#             scopes: mondo.predisposes_towards.mondo
#         outputs:
#         - id: MONDO
#           semantic: Disease
#         parameters:
#           fields: mondo.mondo
#           size: 1000  ## note the size limit
#         predicate: contribution_from
#         ## inverse of contributes_to, which is mapped to "MONDO:predisposes_towards"
#         ## no relation then...
#         source: "infores:mondo"
#         knowledge_level: knowledge_assertion
#         agent_type: manual_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/mondo"
#         testExamples:
#           - qInput: "MONDO:0004979"      ## asthma
#             oneOutput: "MONDO:0010940"   ## inherited susceptibility to asthma
#     disease_shares_features_of:
#       - supportBatch: true
#         useTemplating: true
#         inputs:
#         - id: MONDO
#           semantic: Disease
#         requestBody:
#           body:
#             ## HAS PREFIX (MONDO): currently a bit redundant to do this (BTE handles it)
#             # q: "{{ queryInputs | replPrefix('MONDO', ':') }}"
#             q: "{{ queryInputs }}"
#             scopes: mondo.mondo
#         outputs:
#         - id: MONDO
#           semantic: Disease
#         parameters:
#           fields: mondo.disease_shares_features_of.mondo
#           size: 1000  ## note the size limit
#         predicate: similar_to  ## could biolink have a more specific predicate?
#         ##   note that relation maps to biolink:related_to right now...
#         source: "infores:mondo"
#         knowledge_level: knowledge_assertion
#         agent_type: manual_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/disease_shares_features_of"
#         testExamples:
#           - qInput: "MONDO:0008711"      ## Goodman syndrome
#             oneOutput: "MONDO:0019012"   ## Carpenter syndrome
#     disease_shares_features_of-rev:
#     ## checked and inverse relationship doesn't exist already in the data
#     ##   for example, the record for Carpenter syndrome doesn't have disease_shares_features_of
#       - supportBatch: true
#         useTemplating: true
#         inputs:
#         - id: MONDO
#           semantic: Disease
#         requestBody:
#           body:
#             ## HAS PREFIX (MONDO): currently a bit redundant to do this (BTE handles it)
#             # q: "{{ queryInputs | replPrefix('MONDO', ':') }}"
#             q: "{{ queryInputs }}"
#             scopes: mondo.disease_shares_features_of.mondo
#         outputs:
#         - id: MONDO
#           semantic: Disease
#         parameters:
#           fields: mondo.mondo
#           size: 1000  ## note the size limit
#         predicate: similar_to  ## could biolink have a more specific predicate?
#         source: "infores:mondo"
#         knowledge_level: knowledge_assertion
#         agent_type: manual_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/mondo"
#         testExamples:
#           - qInput: "MONDO:0019012"      ## Carpenter syndrome
#             oneOutput: "MONDO:0008711"   ## Goodman syndrome
#     disease_has_major_feature:
#       - supportBatch: true
#         useTemplating: true
#         inputs:
#         - id: MONDO
#           semantic: Disease
#         requestBody:
#           body:
#             ## HAS PREFIX (MONDO): currently a bit redundant to do this (BTE handles it)
#             # q: "{{ queryInputs | replPrefix('MONDO', ':') }}"
#             q: "{{ queryInputs }}"
#             scopes: mondo.mondo
#         outputs:
#         - id: MONDO
#           semantic: Disease
#         parameters:
#           fields: mondo.disease_has_major_feature.mondo
#           size: 1000  ## note the size limit
#         predicate: has_part  ## maps to "MONDO:disease_has_major_feature"
#         source: "infores:mondo"
#         knowledge_level: knowledge_assertion
#         agent_type: manual_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/disease_has_major_feature"
#         testExamples:
#           - qInput: "MONDO:0015140"      ## early-onset autosomal dominant Alzheimer disease
#             oneOutput: "MONDO:0001627"   ## dementia (disease)
#     disease_has_major_feature-rev:
#       - supportBatch: true
#         useTemplating: true
#         inputs:
#         - id: MONDO
#           semantic: Disease
#         requestBody:
#           body:
#             ## HAS PREFIX (MONDO): currently a bit redundant to do this (BTE handles it)
#             # q: "{{ queryInputs | replPrefix('MONDO', ':') }}"
#             q: "{{ queryInputs }}"
#             scopes: mondo.disease_has_major_feature.mondo
#         outputs:
#         - id: MONDO
#           semantic: Disease
#         parameters:
#           fields: mondo.mondo
#           size: 1000  ## note the size limit
#         predicate: part_of  ## could biolink have a more specific predicate?
#         source: "infores:mondo"
#         knowledge_level: knowledge_assertion
#         agent_type: manual_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/mondo"
#         testExamples:
#           - qInput: "MONDO:0001627"      ## dementia (disease)
#             oneOutput: "MONDO:0015140"   ## early-onset autosomal dominant Alzheimer disease
#     disease_has_feature:
#       - supportBatch: true
#         useTemplating: true
#         inputs:
#         - id: MONDO
#           semantic: Disease
#         requestBody:
#           body:
#             ## HAS PREFIX (MONDO): currently a bit redundant to do this (BTE handles it)
#             # q: "{{ queryInputs | replPrefix('MONDO', ':') }}"
#             q: "{{ queryInputs }}"
#             scopes: mondo.mondo
#         outputs:
#         - id: MONDO
#           semantic: Disease
#         parameters:
#           fields: mondo.disease_has_feature.mondo
#           size: 1000  ## note the size limit
#         predicate: has_part  ## no biolink mapping...
#         source: "infores:mondo"
#         knowledge_level: knowledge_assertion
#         agent_type: manual_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/disease_has_feature"
#         testExamples:
#           - qInput: "MONDO:0005796"      ## HIV enteropathy
#             oneOutput: "MONDO:0005020"   ## intestinal disease
#     disease_has_feature-rev:
#       - supportBatch: true
#         useTemplating: true
#         inputs:
#         - id: MONDO
#           semantic: Disease
#         requestBody:
#           body:
#             ## HAS PREFIX (MONDO): currently a bit redundant to do this (BTE handles it)
#             # q: "{{ queryInputs | replPrefix('MONDO', ':') }}"
#             q: "{{ queryInputs }}"
#             scopes: mondo.disease_has_feature.mondo
#         outputs:
#         - id: MONDO
#           semantic: Disease
#         parameters:
#           fields: mondo.mondo
#           size: 1000  ## note the size limit
#         predicate: part_of
#         source: "infores:mondo"
#         knowledge_level: knowledge_assertion
#         agent_type: manual_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/mondo"
#         testExamples:
#           - qInput: "MONDO:0005020"      ## intestinal disease
#             oneOutput: "MONDO:0005796"   ## HIV enteropathy
#     disease_causes_feature:
#       - supportBatch: true
#         useTemplating: true
#         inputs:
#         - id: MONDO
#           semantic: Disease
#         requestBody:
#           body:
#             ## HAS PREFIX (MONDO): currently a bit redundant to do this (BTE handles it)
#             # q: "{{ queryInputs | replPrefix('MONDO', ':') }}"
#             q: "{{ queryInputs }}"
#             scopes: mondo.mondo
#         outputs:
#         - id: MONDO
#           semantic: Disease
#         parameters:
#           fields: mondo.disease_causes_feature.mondo
#           size: 1000  ## note the size limit
#         predicate: causes  ## maps to "MONDO:disease_causes_feature"
#         source: "infores:mondo"
#         knowledge_level: knowledge_assertion
#         agent_type: manual_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/disease_causes_feature"
#         testExamples:
#           - qInput: "MONDO:0000490"      ## glomerulosclerosis
#             oneOutput: "MONDO:0001106"   ## kidney failure
#     disease_causes_feature-rev:
#       - supportBatch: true
#         useTemplating: true
#         inputs:
#         - id: MONDO
#           semantic: Disease
#         requestBody:
#           body:
#             ## HAS PREFIX (MONDO): currently a bit redundant to do this (BTE handles it)
#             # q: "{{ queryInputs | replPrefix('MONDO', ':') }}"
#             q: "{{ queryInputs }}"
#             scopes: mondo.disease_causes_feature.mondo
#         outputs:
#         - id: MONDO
#           semantic: Disease
#         parameters:
#           fields: mondo.mondo
#           size: 1000  ## note the size limit
#         predicate: caused_by
#         source: "infores:mondo"
#         knowledge_level: knowledge_assertion
#         agent_type: manual_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/mondo"
#         testExamples:
#           - qInput: "MONDO:0001106"      ## kidney failure
#             oneOutput: "MONDO:0000490"   ## glomerulosclerosis
#     disease_arises_from_feature:
#       - supportBatch: true
#         useTemplating: true
#         inputs:
#         - id: MONDO
#           semantic: Disease
#         requestBody:
#           body:
#             ## HAS PREFIX (MONDO): currently a bit redundant to do this (BTE handles it)
#             # q: "{{ queryInputs | replPrefix('MONDO', ':') }}"
#             q: "{{ queryInputs }}"
#             scopes: mondo.mondo
#         outputs:
#         - id: MONDO
#           semantic: Disease
#         parameters:
#           fields: mondo.disease_arises_from_feature.mondo
#           size: 1000  ## note the size limit
#         predicate: caused_by
#         source: "infores:mondo"
#         knowledge_level: knowledge_assertion
#         agent_type: manual_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/disease_arises_from_feature"
#         testExamples:
#           - qInput: "MONDO:0009346"      ## histidinuria due to a renal tubular defect
#             oneOutput: "MONDO:0021568"   ## renal tubule disease
#     disease_arises_from_feature-rev:
#       - supportBatch: true
#         useTemplating: true
#         inputs:
#         - id: MONDO
#           semantic: Disease
#         requestBody:
#           body:
#             q: "{{ queryInputs }}"   ## HAS PREFIX (MONDO)
#             scopes: mondo.disease_arises_from_feature.mondo
#         outputs:
#         - id: MONDO
#           semantic: Disease
#         parameters:
#           fields: mondo.mondo
#           size: 1000  ## note the size limit
#         predicate: causes
#         source: "infores:mondo"
#         knowledge_level: knowledge_assertion
#         agent_type: manual_agent
#         response_mapping:
#           "$ref": "#/components/x-bte-response-mapping/mondo"
#         testExamples:
#           - qInput: "MONDO:0021568"      ## renal tubule disease
#             oneOutput: "MONDO:0009346"   ## histidinuria due to a renal tubular defect
